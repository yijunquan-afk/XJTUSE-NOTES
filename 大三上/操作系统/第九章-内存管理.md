

# 第九章 内存管理

## 9.1 Background（背景）

<img src="https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img/image-20211028142501840.png" alt="image-20211028142501840" style="zoom:50%;" />



程序必须放入内存并放入一个进程才能被执行

输入队列：磁盘上等待进入内存并执行的进程的集合

用户程序在执行前必须经历很多步骤

> 首先，经过编译程序将源代码编译成若干个目标模块，其次通过链接程序将编译好的目标模块以及所需的库函数链接在一起，形成完整的装入模块；最后通过装入程序将这些装入模块装入内存并执行					

<img src="https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img/image-20211028142927540.png" alt="image-20211028142927540" style="zoom:50%;" />

<img src="https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img/image-20211028143020575.png" alt="image-20211028143020575" style="zoom: 50%;" />

:warning: **指令和数据绑定到内存地址可以在三个不同的阶段发生**

> 编译时期Compile time：如果内存位置已知，可生成绝对代码；如果开始位置改变，需要重新编译代码
>
> 装入时期Load time：如果存储位置在编译时不知道，则必须生成可重定位代码
>
> **执行时期Execution time**：如果进程在执行时可以在内存中移动，则地址绑定要延迟到运行时。**需要硬件对地址映射的支持**，例如基址和限长寄存器

示例如下：

<img src="https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img/image-20211028143731772.png" alt="image-20211028143731772" style="zoom:50%;" />

### 逻辑与物理地址空间

**逻辑地址**：由cpu产生，也叫做虚拟空间

**物理地址**：内存设备所读入的地址

在**编译时期和装入时**期的地址绑定策略生成的逻辑地址和物理地址是**相同的**，而在**执行时的地址绑定策略是不同的**。

**【概念】地址重定位**：将程序装入到与其地址空间不一致的物理空间，所引起的一系列地址变换过程。

> **静态地址重定位**
>
> > 在装入一个作业时，把作业中的指令地址全部转换为绝对地址,在作业执行过程中就无须再进行地址转换工作。
>
> **动态地址重定位**
>
> > 动态地址重地位是在程序执行过程中，在CPU访问内存之前,将要访问的程序或数据地址转换成内存地址. 动态重定位依靠硬件地址变换机构完成。

<img src="https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img/image-20211028144653501.png" alt="image-20211028144653501" style="zoom:67%;" />

用户程序所对应到的是逻辑地址，物理地址对它从来都不可见。

### 动态加载

采用动态加载时，一个程序只有在调用时才会加载。能达到更好的内存空间利用率，不需要操作系统的特别支持，通过程序设计实现。

## 9.2 Swapping （交换）

一个进程可以暂时被交换到**内存外的一个备份区**，随后可以被换回内存继续执行。

备份区是一个固定的足够大的可以容纳所有用户内存映像的拷贝；可以提供对这些内存映像的直接存取。

由操作系统控制，利用外存空间（进程交换区），通过对进程实体的整体交换，来满足用户进程的内存需要。它的主要特点是打破了进程运行的驻留性

滚入，滚出——交换由于基于优先级的算法而不同，低优先级的进程被换出，这样高优先级的进程可以被装入和执行。

交换时间的**主要部分是转移时间**，总的转移时间直接同交换的内存的数量成比例。

换出又换入的进程放入的位置取决于地址绑定的策略；如果一个进程正在等待I/O结束，不允许其被换出/I/O的结果数据交给OS来交换

## 9.3 存储管理方式

### Contiguous Allocation（连续分配）

连续分配方式：为一个程序分配一段连续的内存空间，包括单一方式和多分区方式

#### 单一连续分配

主存通常被分为两部分：其中一个存储区域固定地分配给操作系统使用，通常放在低地址部分；另一个存储区域给用户作业

用户区只能容纳一道作业

基址寄存器策略由来保护用户进程（同其他进程和改变的操作系统代码和数据分开

> 基址寄存器包含最小物理地址的值；限长寄存器包含逻辑地址的范围，每个逻辑地址必需比限长寄存器的值小。
>

<img src="https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img/image-20211222144348943.png" alt="image-20211222144348943" style="zoom:67%;" /><img src="https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img/image-20211028151550039.png" alt="image-20211028151550039" style="zoom:67%;margin-left:120px" />      

适用于单道程序，会产生**内碎片**

#### 多分区分配Fixed Partitioning

分区的划分是动态的，不是预先确定的。不同大小的分区分布在整个内存中。适用于多道程序。

:star: **内碎片：一个分区被进程占用后剩下多余的部分；外碎片：无法被任何一个进程占用的小分区**

##### 固定分区分配

固定式分区是在作业装入之前，内存就被划分成若干个固定大小的连续分区。

划分工作可以由系统管理员完成，也可以由操作系统实现。

一旦划分完成，在系统运行期间不再重新划分，即分区的个数不可变，分区的大小不可变，所以，固定式分区又称为**静态分区**。

划分分区的方法如下：

> 分区大小相等：只适用于多个相同程序的并发执行（处理多个类型相同的对象），缺乏灵活性。
>
> 分区大小不等：多个小分区、适量的中等分区、少量的大分区。根据程序的大小，分配当前空闲的、适当大小的分区。

![image-20211028151941993](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img/image-20211028151941993.png)

一般将内存的用户区域划分成大小不等的分区，可适应不同大小的作业的需要 系统有一张**分区说明表**，每个表目说明一个分区的大小、起始地址和是否已分配的使用标志

分区说明表和内存分配图如下所示

![image-20211028152043164](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img/image-20211028152043164.png)

**优点**：**易于实现，开销小。**

**缺点**：

> 分区大小固定: 内碎片
>
> 分区总数固定: 限制并发执行的进程数目。

采用的数据结构：分区表——记录分区的大小和使用情况

##### 可变分区分配（动态）

分区分配算法：寻找某个空闲分区，其大小需大于或等于程序的要求。若是大于要求，则将该分区分割成两个分区，其中一个分区为要求的大小并标记为“占用”，而另一个分区为余下部分并标记为“空闲”。分区的先后次序通常是从内存低端到高端。

分区释放算法：需要将相邻的空闲分区合并成一个空闲分区。(这时要解决的问题是：合并条件的判断)

:question:如何从一个空的分区序列中满足一个申请需要？

> 首次适应：最先找到的
>
> 最佳适应：适应的最小的
>
> 最差适应：适应的最大的

**首次适应算法First Fit**

> 分配和释放的时间性能较好，较大的空闲分区可以被保留在内存高端。
>
> 随着低端分区不断划分而产生较多小分区，每次分配时查找时间开销会增大。
>
> 在系统不断地分配和回收中，必定会出现一些不连续的小的空闲区，称为**外碎片**。虽然可能所有碎片的总和超过某一个作业的要求，但是由于不连续而无法分配。

**最佳适应算法Best Fit**

> 为提高查找效率，空闲分区表（空闲区链）中的空闲分区要按从小到大进行排序，自表头开始查找到第一个满足要求的自由分区分配

解决碎片的方法是**拼接（或称紧凑）**，即向一个方向（例如向低地址端）移动已分配的作业，使那些零散的小空闲区在另一方向连成一片。**动态重定位时才能用紧缩**

**分页存储管理是解决存储碎片的一种方法，要避开连续性要求，允许进程的物理地址空间不连续。**

### External fragmentation（外碎片） 与Internal fragmentation（内碎片）

内碎片指的是已经分配给作业但是不能被利用的内存空间，外部碎片是指系统中还没有分配给作业，但由于碎片太小而无法分配给申请内存空间的新进程的存储块。如固定分区中存在内碎片，动态分区分配中存在外部碎片

## 9.4 Paging（分页）

解决外碎片的方法

把物理内存分成大小固定的块，叫做**帧**frame，把逻辑内存也分为固定大小的块，叫做**页**page。

通过建立页和帧的映射关系，即建立一个页表，把逻辑地址转换为物理地址。

<img src="https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img/image-20211102161650090.png" alt="image-20211102161650090" style="zoom:67%;" />

由CPU生成的每个地址分成两部分：页码page number（p）和偏移page offset（d）。页码作为页表的索引，页表包含每页所在物理内存的基地址，基地址加偏移就形成了物理内存地址。

![image-20211102162636400](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img/image-20211102162636400.png)

逻辑地址由硬件分成两部分

<img src="https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img/image-20211102162658264.png" alt="image-20211102162658264" style="zoom:67%;" />

### 地址结构

图中的地址长度为32位，允许地址空间的大小最多为1M个页。

![image-20211222145947266](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img/image-20211222145947266.png)

程序经过编译链接后形成逻辑地址，对某特定机器其地址结构是一定的。若给定一个逻辑地址为A(十进制)，页面大小为L，则页号P和页内地址W可按下式求得：

![image-20211222150012482](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img/image-20211222150012482.png)

页表十分重要，而它被放在**主存**中，需要两个寄存器：**页表基址寄存器指向页表；页表限长寄存器表明页表的长度**

**在这个机制中，每一次的数据/指令存取需要两次内存存取，一次是存取页表，一次是存取数据**

通过一个联想寄存器TLBs，可以解决两次存取的问题

### 联想寄存器TLB

存的是页号和帧号的对应关系（快表）；**如果页码在联想寄存器中，把帧号取出；否则从内存中的页表中取出帧号**

**例如**

> 假设检索联想存储器的时间为20ns，访问内存的时间为100ns，访问联想存储器的命中率为85%，则CPU存取一个数据的平均时间:

> $T=0.85\times120+0.15\times220=135ns$
>
> 访问时间只增加35%。如果不引入联想存储器，其访问将延长一倍（达200ns）。

### 地址变换机构

实现从逻辑地址到物理地址的转换:将用户程序中的页号变换成内存中的物理块号

地址变换机构：

> 页表寄存器
>
> 有效地址寄存器（逻辑地址寄存器）
>
> 物理地址寄存器
>
> 页表
>
> PCB中增加存放页表始址和页表长度的项

###  地址变换过程

:one: 按页的大小分离出页号和位移量，放入有效地址寄存器中

:two: 将页号与页表长度进行比较，如果页号大于页表长度，越界中断；

:three: 以页号为索引查找页表:将页表始址与页号和页表项长度的乘积相加，便得到该表项在页表中的位置，于是可从中得到该页的物理块号；

:four: 将该物理块号装入物理地址寄存器的高址部分；

:five: 将有效地址寄存器中的位移量直接复制到物理地址寄存器的低位部分，从而形成内存地址。

<img src="https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img/image-20211102164315984.png" alt="image-20211102164315984" style="zoom:50%;" /><img src="https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img/image-20211222150449183.png" alt="image-20211222150449183" style="zoom:50%;" />

> 虚地址（逻辑地址、程序地址）以十六进制、八进制、二进制的形式给出
>
> > 将虚地址转换成二进制的数；
> >
> > 按页的大小分离出页号和位移量（低位部分是位移量，高位部分是页号）；
> >
> > 将位移量直接复制到内存地址寄存器的低位部分；
> >
> > 以页号查页表，得到对应页装入内存的块号，并将块号转换成二进制数填入地址寄存器的高位部分，从而形成内存地址。
>
> 虚地址以十进制数给出
>
> > 页号＝虚地址％页大小
> >
> > 位移量＝虚地址 mod 页大小
>
> 以页号查页表，得到对应页装入内存的块号
>
> 内存地址＝块号×页大小＋位移量

#### 举例

<img src="https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img/image-20211102164752569.png" alt="image-20211102164752569" style="zoom:67%;" />

> 低十一位是页内偏移，高位为页号

<img src="https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img/image-20211102165010104.png" alt="image-20211102165010104" style="zoom:57%;" />

### 页的共享与保护

在分页存储管理系统中，实现共享的方法是使**共享用户地址空间中的页指向相同的物理块。**

在分页存储管理系统中实现共享比在分段系统中要困难。这是因为，分页存储管理系统中将作业的地址空间划分为页面的做法对用户是透明的，同时作业的地址空间是线性连续的，当系统将作业的地址空间分成大小相同的页面时，被共享的部分不一定包含在一个完整的页面中，这样不应该共享的数据也被共享了，不利于保密。另外，共享部分的起始地址在各作业的地址空间划分成页的过程中，在各自页面中的页内位移可能不同，这也会使共享比较困难。

分页存储管理系统可以为内存提供两种保护方式：**一种是地址越界保护；另一种是通过页表中的访问控制信息对内存信息提供保护**。

内存的保护由与每个页框相连的保护位来执行。

有效-无效位附在页表的每个表项中

> “有效”表明相关的页在进程的逻辑地址空间，以及是一个合法的页。
>
> “无效”表明页不在进程的逻辑地址空间中。

<img src="https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img/image-20211102165311715.png" alt="image-20211102165311715" style="zoom: 90%;" />

## 9.5 页表结构

### 两级页表

为了减少页表所占用的连续的内存空间，采用了两级页表机制.

<img src="https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img/image-20211102165847412.png" alt="image-20211102165847412" style="zoom:60%;" />

逻辑地址被分成三部分：外部页表、内部页表、偏移

![image-20211102170115842](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img/image-20211102170115842.png)

> 由于每一级都分开的以表的形式存储在内存中，把一个逻辑地址转换为一个物理地址可能要进行4次内存存取。）
>
> 多级页表的引入，使逻辑地址到物理地址的变换时间增加了许多:二级页表需三次访存,三级页表需四次访存,四级页表需五次访存
>
> 尽管每次内存存取的时间是很大的，高速缓存使执行的时间还是可以接受的。

访问的时间增加了

### 哈希页表

<img src="https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img/image-20211102171917982.png" alt="image-20211102171917982" style="zoom:67%;" />

### 反转页表

通常的页表为每个进程设置一张页表，其不足之处是浪费内存空间

解决：**倒置页表，按照整个物理内存建造一张表**

内存中的每一块在表中占一项。 

每项包含存储在物理内存的进程的逻辑页号和进程标示。

减少了页表占用的内存空间量,但是增加了查找表的时间，因为页表是按物理块的顺序组织的，而查找是按虚地址进行的。 

使用哈希表来减少搜索。

### 分页特点

**优点**

> **内存利用率高、实现了离散分配、便于存储访问控制、无外部碎片**

**缺点**

> **需要硬件支持（尤其是快表）、内存访问效率下降、共享困难、内部碎片**

## 9.6 Segmentation（分段）

一个程序是一些段的集合，一个段是一个逻辑单位，如：

>  main program,
>
>  procedure,
>
>  function,
>
>  local variables, global variables,
>
>  common block,
>
>  stack,
>
>  symbol table, arrays

一个逻辑地址是两个向量的集合：基地址+偏移

**段表：段的基地址+段长(页表是固定大小的)**

<img src="https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img/image-20211102174010450.png" alt="image-20211102174010450" style="zoom:67%;" />

属于动态重定位

<img src="https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img/image-20211102174309777.png" alt="image-20211102174309777" style="zoom:67%;" />

地址变换过程

> **系统将逻辑地址中的段号S与段表长度TL进行比较。若 S≥TL，访问越界；**
>
> **若未越界，则根据段表的始址和该段的段号，计算出该段对应段表项的位置，从中读出该段在内存中的起始地址；**
>
> **然后再检查段内位移d是否超过该段的段长SL。若超过，即 d≥SL，同样发出越界中断信号；**
>
> **若未越界，则将该段的基址与段内位移d相加，得到要访问的内存物理地址。**

![image-20211102174459913](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img/image-20211102174459913.png)

### 段的共享与保护

在分段存储管理系统中，分段的共享是通过使多个作业的段表中相应表项都指向被**共享段的同一个物理副本来实现的。**

在多道程序环境下，必须注意共享段中信息的保护问题。当一一个作业正从共享段中读取数据时，必须防止另一个作业修改此共享段中的数据。在当今大多数实现共享的系统中，程序被分成代码区和数据区。不能修改的代码称为纯代码或可重入代码，这样的代码和不能修改的数据是可以共享的，而可修改的程序和数据则不能共享。

与分页管理类似，分段管理的保护主要有两种:**地址越界保护和访问控制保护**。关于访问控制保护的实现方式前面已经介绍过，这里不再重复。而地址越界保护则是利用段表寄存器中的段表长度与逻辑地址中的段号进行比较，若段号大于段表长度，则产生越界中断;再利用段表项中的段长与逻辑地址中的段内位移进行比较，若段内位移大于段长，则会产生越界中断。不过在允许段动态增长的系统中，段内位移大于段长是允许的。为此，段表中应设置相应的增补位以指示该段是否允许动态增长。

### 分段的特点

程序通过分段(segmentation)划分为多个模块，如代码段、数据段、共享段。

> 可以分别编写和编译
>
> 可以针对不同类型的段采取不同的保护
>
> 可以按段为单位来进行共享，包括通过动态链接进行代码共享

**特点**：

> **没有内碎片，外碎片可以通过内存紧缩来消除。**
>
> 便于改变进程占用空间的大小。
>
> 进程全部装入内存。

### 分段与分页的比较

|              |                           分 页                            | 分 段                                                        |
| ------------ | :--------------------------------------------------------: | :----------------------------------------------------------- |
| 目的         |                   为了提高内存的利用率；                   | 为了能更好地满足用户的需要。                                 |
| 单位划分     | **页是信息的物理单位，页的大小是固定的，而且由系统确定。** | 段是**信息的逻辑单位**,它含有一组意义相对完整的信息。段的长度是不固定的，取决于用户所编写的程序，并由编译程序来划分。 |
| 作业地址空间 |                     单一的线性地址空间                     | 二维的，标识一个地址需给出段名和段内地址。                   |
| 内存分配     |       以页为单位离散分配，无外碎片，所以也无紧缩问题       | 以段为单位离散分配，类同可变分区，会产生许多分散的小自由分区——外碎片，造成主存利用率低，需采用紧缩解决碎片问题，但紧缩需花费时间 |

## 9.7 Segmentation with Paging（段页式）

既具有分页系统能有效地**提高内存利用率**的优点，又具有分段系统能很好地**满足用户需要**的长处，是一种有效的存储管理方式。

### 基本原理

将整个主存划分成大小相等的物理块（页框）

把用户程序按程序的逻辑关系分为若干个段，并为每个段赋予一个段名

把每个段划分成若干页，以页框为单位离散分配。

地址结构由**段号、段内页号和页内地址**三部分组成

<img src="https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img/image-20211102175943286.png" alt="image-20211102175943286" style="zoom:67%;" />

为了实现从逻辑地址到物理地址的变换，系统中需同时配置**段表和页表**。

由于将段中的页进行离散地分配，段表中的内容不再是段的内存始址和段长，而是**页表始址和页表长度**。 

![image-20211102180035741](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img/image-20211102180035741.png)

![image-20211109210930145](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img/image-20211109210930145.png)

### 地址变换过程

> 将段号S与段长TL进行比较
>
> 若S＜TL，表示未越界，于是利用段表始址和段号求出该段对应的段表项在段表中的位置，从中得到该段的页表始址与页表长度
>
> 将逻辑地址中的段内页号P与页表长度PL进行比较:若P＜PL，则用页号来获得对应页的页表项位置，从中读出该页所在的物理块号b
>
> 用块号 b和页内地址构成物理地址

在段页式系统中，为了获取一条指令或数据，需**三次访问内存**。

> 第一次是访问内存中的段表，从中取得页表始址
>
> 第二次是访问内存中的页表，从中取得物理块号，并将该块号与页内地址一起形成物理地址
>
> 第三次才是真正从第二次访问所得到的物理地址中，取得指令或数据。

