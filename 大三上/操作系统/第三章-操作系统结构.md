

# 第三章 操作系统结构

## 3.1 Operating System Services操作系统服务

操作系统提供的服务如下：

> - **用户界面：包括命令行界面与图形化界面**
> - **程序执行**
> - **I/O操作**
> - **文件系统操作**
> - **通信：两种方式：共享内存与消息交换(进程部分会细讲)**
> - **错误检测**
>

其他的功能不是用于帮助用户，而是为了系统效率：

- Resource allocation 资源分配 ：把资源分配给多个用户或多个同时运行的作业
- Accounting帐务：跟踪和记录用户对资源的使用，用于帐单和统计
- Protection 保护：确保对资源的所有访问均在控制中

![image-20211221141947085](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img/image-20211221141947085.png)



## 3.2 System Calls系统调用

### 1、系统调用的概念

**系统调用提供在运行程序和操作系统之间的接口，属于一个软中断**

通常以汇编语言指令形式提供；替代汇编语言的、供系统编程的语言，允许直接使用系统调用

主要由程序通过**高级应用程序接口(API)**访问，而不是直接系统调用使用

三个最常见的API

> Windows的Win32 API
>
> POSIX API用于基于POSIX的系统(包括几乎所有版本的UNIX、Linux和Mac OS X)
>
> 用于Java虚拟机(JVM)的Java API

系统调用的处理机构:陷入（TRAP）或异常处理机构

把由于系统调用引起处理机中断的指令称为**陷入或异常指令（或称访管指令）**

### 2、系统调用的过程

:one: 当用户使用系统调用时，产生一条相应的指令

:two: CPU在执行到该指令时发生中断，发出有关的信号给陷入处理机构；

:three: 在处理系统调用之前，陷入处理机构还需**保存处理机现场**（PSW、PC、系统调用号、用户栈指针、通用寄存器、用户定义的参数等）

:four: 处理机构在收到了CPU发来的信号后，启动相关的处理程序去完成该系统调用所要求的功能

:five: 如何找到实现系统调用功能的子程序:**入口地址表**，每个入口地址与相应的系统程序对应

:six: 陷入处理程序用系统调用功能号查找入口地址表,得到该系统程序的入口地址,并执行之

:seven: 系统调用处理结束后，要恢复处理机现场，从而用户程序可以继续执行



![image-20211003164249246](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img/image-20211003164249246.png)

### 3、向操作系统传递参数的常见方式

  3种常用方式用于在运行程序和操作系统之间的参数传递：

:one: Pass parameters in *registers*寄存器中的参数传递

:two: 参数存在内存的一张表中，表地址作为寄存器的参数传递

此时，这些参数存在内存的块或者表中，而块和表中的地址通过寄存器来传递

![image-20211003170141181](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img/image-20211003170141181.png)

:three: 程序把参数压入栈，由操作系统弹出

### 4、系统调用的类型

六大类：进程控制、文件管理、设备管理、信息维护、通信、保护 

## 3.3 System Programs系统程序

**系统程序提供程序开发和执行的便利环境**。可划分为：

> 文件操作、状态信息、文件修改、程序语言支持、程序调入与执行、通信、应用程序

大多数用户看到的操作系统是由系统程序定义而不是实际的系统调用定义的

## 3.4 System Components系统部件

Process Management 进程管理

Main Memory Management主存管理

Secondary-Storage Management 二级储存器管理

I/O System Management I/O系统管理

File Management 文件管理

Protection System 保护系统

Networking 网络处理

Command-Interpreter System 命令解释器系统

## 3.5 System Structure 系统结构

### 1、简单结构Simple Approach 

**MS-DOS**

MS-DOS 以最小的空间提供最多的功能

> 不划分模块
>
> 尽管有某种结构，其接口与功能层没有划分清楚

应用程序可直接访问BIOS例程，来直接操纵设备，当然这受限于当时的硬件，intel8088没提供双模式和硬件保护，这使得DOS别无选择只能任由应用程序访问BIOS.

![image-20211015213656837](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img/image-20211015213656837.png)

**UNIX**

受硬件功能限制，早期UNIX只是有限的结构化。 UNIX包括2个分离的部分:系统程序与内核

内核包括了在物理硬件之上，系统调用之下的一切，提供文件系统、CPU调度、存储管理和其他操作系统功能：每一层有大量的功能

![image-20211015214509920](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img/image-20211015214509920.png)

### 2、层次化结构Layer Structure

分层法：操作系统划分为若干层，在低层上构建高层。底层（0层）为硬件；最高层（ N层）为用户层

**分层的基本原则**

> 每一层都使用其底层所提供的功能和服务，以便于系统调试和验证。

**困难**

> 层次的划分和安排，要保证不出现双向依赖关系

![image-20211015214831105](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img/image-20211015214831105.png)

**优点**(<font color="red">重点</font>)

> :one: 低层和高层可分别实现（便于扩充）；
>
> :two: 高层错误不会影响到低层，便于调试、利于功能的增删改；
>
> :three: 调用关系清晰（高层对低层单向依赖），避免递归调用，有利于保证设计和实现的正确性 

**缺点**

> 系统中所有进程的控制转移、通讯等任务全部交给系统的核心去管理，要花费一定的代价

### 3、微内核Microkernels

**Mach 首先使用微内核结构，**典型系统如MACH和Windows NT

通过划分系统程序和用户程序，把所有不必要的部件移出内核，形成一个小内核，微内核提供最少量的进程管理、存储管理，以及通信功能

操作系统由**两大部分**组成

> 运行在核心态的内核
> 运行在用户态并以C/S方式运行的进程层

基于微内核结构的OS和传统OS相比，具有以下特点：

:one: **内核精巧**．通常内核只由<font color="red">任务管理、虚存管理和进程间通信3个部分</font>组成．传统OS内核中的许多部分都被移出内核．采取服务器方式实现；

:two: **面向多处理机和分布式系统**．基于微内核的OS，在内核中引入了多处理机调度和管理机制，并引入了细粒度并发机制——线程，使得多个处理机可以在同一个任务中并行地执行；

:three:  **基于客户／服务器体系结构**．在微内核结构的OS中，任务间通信机制—— 消息机制是系统的基础，OS的各种功能都以服务器方式实现，向用户提供服务．用户对服务器的请求是以消息传递的方式传给服务器的．

<font color="red">优点</font>

> 易于扩充，易于移植
> 提高系统的可靠性：
> 提供多种操作环境
> 便于实现分布计算：以同样的调用形式，在下层可通过核心中的网络传送到远方服务器上  (RPC, Remote Procedure Call)

<font color="red">缺点</font>

> 消息传递方式增加开销，使响应变慢

### 4、模块

**可加载的内核模块**

> 使用面向对象的方法 
>
> 每个核心组件都是分开的
>
> 每个都通过已知的界面与其他人联系
>
>  每个都可根据需要在内核内加载

内核提供核心服务，其他服务在内核运行时可动态加载，类似于分层，但是更加灵活，任何模块可以彼此调用，也类似于微内核，主模块只有核心功能，并知道如何加载其他模块和如何让模块进行通信

### 5、混合系统

大多数现代操作系统都不是单纯的一个结构，而是会采用多种结构

## 3.6 Virtual Machines虚拟机

**虚拟机是层次化的逻辑结果**。它把硬件和操作系统看成都是硬件，虚拟机为裸机提供了统一的接口，操作系统创建了多个进程，每一个进程有自己的处理器和（虚拟）内存

**实现方式**：分时，共享

**物理计算机的资源被共享，以创建虚拟机**

> CPU调度使得用户好像有自己的处理器
>
> Spooling（外部设备练级并行操作）和文件系统提供了虚拟卡片阅读机和打印机
>
> 普通用户终端成为虚拟机操作员的控制台

**优缺点**

> 虚拟机概念提供对**系统资源的完全保护**，因为每个虚拟机同其他虚拟机隔离。当然，隔离不允许直接共享资源
>
> 虚拟机是**研发操作系统的完美载体**。系统开发在虚拟机上而不是在物理硬件上完成，从而不会打扰正常系统运行
>
> 由于需要对下面的机器进行精确的复制，所以虚拟机的**概念实现困难**

## 3.7 系统设计目标

用户目标 ：操作系统应该便于使用，易学，可靠，安全并且快捷

系统目标 ：操作系统应该容易设计、实现和维护，还要灵活、可靠、无错误和高效