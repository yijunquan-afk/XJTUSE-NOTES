

# 第八章 死锁

## 死锁产生的原因和必要条件

【概念】**死锁Deadlock**：计算机系统中多道程序并发执行时，两个或两个以上的进程由于竞争资源而造成的一种**互相等待**的现象（僵局），如无外力作用，这些进程将永远不能再向前推进。

**共享资源的获取和释放**

> request (申请)：如果申请不能立即被允许，那么进程必须等待直到能获取资源。（通过系统调用或者信号量来进行资源的申请和释放）
>
> use (使用)：进程使用资源进行相关操作
>
> Release(释放)：进程释放资源

如果一个进程要使用OS管理的资源，需先向系统提出申请，如果有可用资源，系统才进行分配。

**资源的分类**

:one: 根据资源性质：

> 可抢占资源—指资源占有进程虽然需要使用该资源，但另一个进程却可强行把资源从占有者进程处抢来。
>
> 不可抢占资源—指只有占用者进程不再需要使用该资源而主动释放资源外，其它进程不得在占有者进程使用资源过程中强行抢占。
>
> **一个资源是否属于可抢占资源，完全取决于资源本身的性质**

:two: 根据使用方式：共享资源和独占资源。

:three: 根据使用期限；永久资源和临时性资源。系统模型

<img src="https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img/image-20211026162748420.png" alt="image-20211026162748420" style="zoom:60%;" />

**死锁的原因**

:one: 竞争资源引起死锁

> 当系统中供多个进程所使用的资源，不足以同时满足它们的需要时，引起它们对资源的竞争而产生死锁

:two: 进程推进顺序不当引起死锁

> 在多道程序系统中，并发执行的进程推进序列不可预测
>
> 有些推进顺序，进程可以顺利完成
>
> 有的推进顺序会引起进程无限期地等待永远不会发生的条件而不能向前推进，造成死锁

## 死锁特征Deadlock Characterization

四个条件同时出现，死锁将会发生

**:one: Mutual exclusion互斥**：一次只有一个进程可以使用一个资源

**:two: Hold and wait占有并等待**：一个进程应该占有至少一个资源，并等待另一个资源，而该资源被另一个进程所占有

**:three: No preemption不可抢占**：一个资源只有当持有它的进程完成任务后自由的释放

**:four: Circular wait循环等待**：等待资源的进程之间存在环



## 资源分配图

一个顶点的集合V和边的集合E

V被分为两个部分：P：含有系统中全部的进程；R：含有系统中全部的资源

请求边：直接$P_i->R_j$             分配边： $R_j -> P_i$

![image-20211026164306727](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img/image-20211026164306727.png)

如果图没有环，那么不会有死锁

如果图有环

> 如果每一种资源类型只有一个实例，那么死锁发生
>
> 如果每种资源类型有多个实例，可能死锁

![image-20211222102443093](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img/image-20211222102443093.png)

## 处理死锁的方法

目前处理死锁的方法有以下四种：

> **鸵鸟算法**：视而不见
>
> **预防死锁**：抑制死锁的必要条件
>
> **避免死锁**：在资源的动态分配过程中，用某种方式防止系统进入不安全状态
>
> **检测与解除死锁**：检测出死锁的产生，然后采用某种措施解除

### 鸵鸟算法

忽略这个问题，假装系统中从未出现过死锁。这个方法被大部分的操作系统采用，包括UNIX）鸵鸟策略

### 预防死锁Deadlock Prevention 

抑制死锁的必要条件

**互斥**：共享资源不是必须的，必须保持非共享资源

**占有并等待**：**必须保证进程申请资源的时候没有占有其他资源**

> 要求进程在执行前一次申请全部的资源
>
> 没有资源时，可以申请资源。在申请更多其它资源之前，需要释放已有资源
>
> **利用率低，可能出现饥饿**

**非抢占**：如果一个进程的申请没有实现，它要释放所有占有的资源；抢占的资源放入进程等待资源列表中，只有进程能够重新得到旧的资源和新申请的资源时，才可以重新开始

**循环等待**：将所有的资源类型放入资源列表中，并且要求进程按照资源表申请资源；编号递增申请

死锁预防的副作用：

> 降低设备利用率和吞吐量
>
> 可能有进程饥饿

### 死锁避免

允许进程**动态地**申请资源，系统在进行资源分配之前，先计算资源分配的安全性

若此次分配不会导致系统从**安全状态向不安全状态**转换，便可将资源分配给进程；否则不分配资源，进程必须阻塞等待。

安全状态是**指系统的一种状态，在此状态下,系统能按某种顺序（例如P1、P2……Pn）来为各个进程分配其所需资源，直至最大需求，使每个进程都可顺序地一个个地完成。这个序列（P1、P2…….Pn）称为安全序列。**

若某一时刻不存在一个安全序列，则称系统处于不安全状态。

> 如果一个系统在安全状态，就没有死锁
>
> 如果系统死锁，则处于不安全状态
>
> 如果一个系统处于不安全状态，就有可能死锁
>
> 可以存在多个安全序列

#### 资源分配图算法

**当一种资源只有一个实例**

需求边$P_i->R_j$  代表进程Pi可能会申请资源Ri，表示为虚线

一个进程申请资源的时候，需求边转化为请求边

当资源被进程释放的时候，分配边转化为需求边

系统中的资源必须被事先声明

当一个进程Pi 申请资源Rj时，由循环检测算法来检查:

> 如果把图中的申请边$P_i->R_j$ 转为分配边$R_j -> P_i$ ，图中是否会出现环路，只有不出现环路，才实施资源分配。

#### 银行家算法

```
在银行中，客户申请贷款的数量是有限的，每个客户在第一次申请贷款时要声明完成该项目所需的最大资金量，在满足所有贷款要求时，客户应及时归还。银行家在客户申请的贷款数量不超过自己拥有的最大值时，都应尽量满足客户的需要。在这样的描述中，银行家就好比操作系统，资金就是资源，客户就相当于要申请资源的进程。
```

**当一种资源有多个实例**

当一个进程请求资源，它可能要等待

当一个进程得到所有的资源，它必须在有限的时间释放它们

每一个进程必须事先声明使用的最大量

**数据结构**

n为进程的数目，m为资源类型的数目

Available：如果available[j]=k,那么资源Rj有k个实例有效

Max：如果Max[i,j]=k,那么进程Pi可以最多请求资源Rj的k个实例

Allocation：如果Allocation[i,j]=k,那么进程Pj当前分配了k个资源Rj的实例

Need：如果Need[i,j]=k,那么进程Pi 还需要k个资源Rj的实例

![image-20211026171900404](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img/image-20211026171900404.png)

**资源请求算法**

设$Request_i$为进程Pi的请求向量，如果$Requset_i[j]==k$,那么进程Pi需要资源类型Rj的实例数量为k，当进程Pi作出在这一资源请求时：

:one: 如果$Requset_i\le Need_i$，转到第2步，否则生成出错条件，这是因为进程$P_i$已经超过了其最大需求。

:two: 如果$Requset_i\le Available$，转到第3步，否则Pi应该等待，因为没有资源可用

:three: 假设系统可以分配给进程Pi请求的资源，并按以下方式修改状态

![image-20211026173833258](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img/image-20211026173833258.png)

:four: 用安全算法检查系统是否处在安全状态

**安全算法**

![image-20211026174212179](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img/image-20211026174212179.png)

<img src="https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img/image-20211222110712565.png" alt="image-20211222110712565" style="zoom: 50%;" />

**举例**

5个进程P0到P4:3个资源类型A(10个实例），B（5个实例），C（7个实例）

<img src="https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img/image-20211026174521361.png" alt="image-20211026174521361" style="zoom:80%;" />

![image-20211026174805259](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img/image-20211026174805259.png)

### 死锁检测

检测死锁与恢复策略

#### 每种资源只有一个实例

等待图法——有环就有死锁

#### 每种资源有多个实例

<img src="https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img/image-20211222110040556.png" alt="image-20211222110040556" style="zoom:50%;float:left" /><img src="https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img/image-20211222110819324.png" alt="image-20211222110819324" style="zoom:50%;" />

![image-20211222111344136](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img/image-20211222111344136.png)

### 死锁恢复

**进程终止**

> 终止所有的死锁进程
>
> 一次终止一个进程直到死锁环消失
>
> 选择终止顺序：进程的优先级；进程计算了多少时间，还需要多少时间

**资源抢占**

> 逐步从进程中抢占资源，直到打破死锁
>
> 回退：返回到安全的状态，然后重新开始进程
>
> 饥饿：同一个进程可能总是被选中，包括在回退时

### 

