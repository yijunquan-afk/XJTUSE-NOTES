[TOC]

# 第一章 算法概述与NP完全性理论

## 思维导图

![img](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img13/1695718473.png)

## 1、算法与程序

算法**是指解决问题的一种方法或一个过程。**

算法是若干指令的有穷序列，满足性质：

:one: **输入**：有外部提供的量作为算法的输入。

:two: **输出**：算法产生至少一个量作为输出。

:three: **确定性**：组成算法的每条指令是清晰，无歧义的。

:four: **有限性**：算法中每条指令的执行次数是有限的，执行每条指令的时间也是有限的。

程序是算法用某种程序设计语言的具体实现。

程序可以不满足算法的性质(4)。例如操作系统，是一个在无限循环中执行的程序，因而不是一个算法。

## 2、算法的复杂度分析

算法运行所需要的计算机资源的量称为**算法的复杂性**。其中包括：算法的时间复杂性*T*(*n*)与算法的空间复杂性*S*(*n*)。*n*是问题的规模（输入大小）。

计算算法运行所需资源量的过程称为算法复杂性分析，简称为**算法分析**。 

这里主要谈论时间复杂度分析。

## （1）时间复杂度分析

:one: **最坏情况**下的时间复杂性
$$
T_{max}(n)=max\{{T(I)\ |\ size(I)=n}\}
$$
:two: **最好情况**下的时间复杂性
$$
T_{min}(n)=min\{{T(I)\ |\ size(I)=n}\}
$$
:three: **平均情况**下的时间复杂性
$$
T_{avg}(n)=\sum_{size(I)=n}p(I)T(I)
$$
其中I是问题的规模为*n*的实例，*p*(I)是实例I出现的概率。

以上三种情况下的时间复杂性从某个角度反应算法的效率，各有用处，实践表明，可操作性最好且最具有价值的是**最坏情况下的时间复杂度**。

### 1）渐进复杂性的概念

如果 $ {\lim_{n \to +\infty}T(n)\to\infty} $ ，而且  ${\lim_{n \to +\infty}\frac{T(n)-t(n)}{T(n)}\to 0}$，则说*t*(*n*)是*T*(*n*)的渐近性态，为算法的渐近复杂性。在数学上， *t*(*n*)是*T*(*n*)的渐近表达式，是*T*(*n*)略去低阶项留下的主项。它比*T*(*n*) 简单。

### 2）渐进分析的记号

在下面的讨论中，对所有*n*，*f*(*n*)>=0，*g*(*n*) >= 0。**常用的是前三个**

:one: 渐近上界记号*O*

$ O(g(n))$={$f(n)$ | 存在正常数*c*和$n_{0}$使得对所有$n\ge n_{0}$有：$ 0\le f(n) \le cg(n) $}

**某种意义上相当于"<="**

**举例 ** f(n) = 2n + 5= O(n)

> 当n≥3时，2n+5≤3n，
>
> 所以，可选c = 3，n0 = 5。对于n≥n0，f(n) = 2n + 5≤3n，
>
> 所以， f(n) = O(n) 。这意味着，当n≥5时，该程序不会超过3n。



:two: 渐近下界记号 $ \Omega$

$ \Omega(g(n))$={$f(n)$ | 存在正常数*c*和$n_{0}$使得对所有$n\ge n_{0}$有： $ 0\le cg(n) \le f(n) $}

**某种意义上相当于">="**

**举例** f(n) = 2n + 3 =Ω(n)

> 对所有n，2n+3≥2n，可选c = 2，n0=0。
>
> 对于n≥n0，f(n) = 2n+3≥2n，所以，f(n) = Ω(n)，即2n + 3∈Ω(n)。



:three:  紧渐进界记号 $\Theta$

$ \Theta(g(n))$={$f(n)$ | 存在正常数*$c_{1}、c_{2}$*和$n_{0}$使得对所有$n\ge n_{0}$有：$  c_{1}g(n) \le f(n) \le c_{2}g(n) $}

**某种意义上相当于"="或者同阶**

上述三种记号的图示如下

![在这里插入图片描述](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img13/1695718474.png)



:four: 非紧上界记号 $o$

$o(g(n))$={$f(n)$ | 对于任何正常数*c>0*，存在正数$n_{0>0}$使得对所有$n\ge n_{0}$有：$0\le f(n) < cg(n)$}

等价于${\lim_{n \to +\infty}\frac{f(n)}{g(n)}\to 0}$，通俗理解为$f(n)$ 的阶低于$g(n)$ 的阶。
**某种意义上相当于"<"**



:five: 非紧下界记号 $\omega$

$\omega(g(n)) =${$f(n)$ | 对于任何正常数*c>0*，存在正数$n_{0>0}$使得对所有$n\ge n_{0}$有： $0\le cg(n) < f(n)$}

等价于${\lim_{n \to +\infty}\frac{f(n)}{g(n)}\to \infty}$，通俗理解为$f(n)$ 的阶高于$g(n)$ 的阶。
**某种意义上相当于">"**

有如下公式： $f(n)\in\omega(g(n))\Leftrightarrow g(n)\in o(f(n))$

渐进阶由低到高为：$常数<\log n<n^{\frac{1}{2}}<n<n^2<3^n<n!$



### 3）渐进分析的算术运算与证明(必须会，7分)

常用公式：

> •*O*(*f*(*n*))+*O*(*g*(*n*)) = *O*(max{*f*(n),*g*(*n*)}) ；
>
> •*O*(*f*(*n*))+*O*(*g*(*n*)) = *O*(*f*(n)+*g*(*n*)) ；
>
> •*O*(*f*(*n*))*O*(*g*(*n*)) = *O*(*f*(n)**g*(*n*)) ；
>
> •*O*(*cf*(*n*)) = *O*(*f*(n)) ；
>
> •*g*(*n*)= *O*(*f*(*n*)) $\Rightarrow$ *O*(*f*(*n*))+*O*(*g*(*n*)) = *O*(*f*(n)) 

证明示例：以第一个公式举例

> •规则*O*(*f*(*n*))+*O*(*g*(*n*)) = *O*(max{*f*(n),*g*(*n*)}) 的**证明：**
>
> •对于任意*f*1(*n*)$\in$ *O*(*f*(*n*)) ，存在正常数*c*1和自然数*n*1，使得对所有*n*$\ge$*n*1，有*f*1(*n*)$\le$*c*1*f*(*n*) 。
>
> •类似地，对于任意*g*1(*n*)$\in$  *O*(*g*(*n*)) ，存在正常数*c*2和自然数*n*2，使得对所有*n*$\ge$ *n*2，有*g*1(*n*) $\le$*c*2*g*(*n*) 。
>
> •令*c*3=max{*c*1, *c*2}， *n*3 =max{*n*1, *n*2}，*h*(*n*)= max{*f*(n),*g*(*n*)} 。
>
> •则对所有的 *n*$\ge$ *n*3，有
>
> •*f*1(*n*) +*g*1(*n*) $\le$*c*1*f*(*n*) + *c*2*g*(*n*) 
>
>   $\le$ *c*3*f*(*n*) + *c*3*g*(*n*)= *c*3(*f*(*n*) + *g*(*n*))
>
>  $\le$ *c*3$\times$2 max{*f*(n),*g*(*n*)}
>
>   = 2*c*3*h*(*n*) 
>
> 则有*f*1(*n*) +*g*1(*n*)=*O(h(n))*= *O*(max{*f*(n),*g*(*n*)}) 
>
> 即*O*(*f*(*n*))+*O*(*g*(*n*)) = *O*(max{*f*(n),*g*(*n*)}) 

**n的阶乘**

Stirling’s approximation 是对n !趋于无穷速度的估计，公式如下
$$
n!=\sqrt{2\pi n}(\frac{n}{e}^n)(1+\Theta(\frac{1}{n}))
$$
可推导：
$$
n!=o(n^n)\ \ \ n!=\omega(2^n)\ \ \ \log(n!)=\Theta(n\log n)
$$

### 4）算法基本法则

对于非递归算法，其时间复杂度遵循以下基本法则

:one: for / while 循环

循环体内计算时间*循环次数；

:two: 嵌套循环

循环体内计算时间*所有循环次数；

:three: 顺序语句

各语句计算时间相加；

:four: if-else语句

if语句计算时间和else语句计算时间的**较大者**。



## 3、NP完全性理论（3-6分 选择)

如何区分一个问题是“易”还是“难”？通常将可在多项式时间内解决的问题看作“易”解决问题；需要指数函数时间内解决的问题看作“难”解决问题。

**对于每个最优化问题，都可以转化为判定问题，判定问题更容易求解。**

以下就是P类问题与NP类问题的定义与解释。

### (1) P类问题与NP类问题定义

:question: **P类问题(easy to find)**

**在确定型图灵机上多项式时间内可解决的问题（自然在多项式时间内可验证）**

例如：求100以内的正整数之和，这个问题可以在有限可接受的时间内解决，属于P类问题

:question: **NP类问题(easy to check)**

**在确定型图灵机上多项式时间可验证，在非确定型图灵机上多项式时间可解的问题**

例如：计算地球上所有原子的个数，这个问题十分困难甚至无解，但是说有200个，我们显然可以验证它是错的，这种就属于NP问题

### (2) 二者的关系

P类问题属于NP类问题，但是NP类问题是否属于P类问题还未确定

### (3) NPC类问题

NPC问题又称为NP完全问题，是大量的NP问题经过规约化后得到的问题，它具有一个神奇的性质：如果一个NP完全问题能在多项式时间内得到解决，那么NP中的所有问题都能在多项式时间内得到解决。公式如下：
$$
X\in NPC: 1、X\in NP;\ 2、\forall \ Y\in NP,有Y\le\ _{p}X
$$
举例如下：

> 第一个NP完全问题（Cook定理  1971）： 布尔表达式的可满足性问题是NP完全问题
>
> 六个NP完全问题（Karp 1972)：  3SAT，3DM，VC，团，HC，划分
>
> 旅行售货员

如何解决NPC问题？并行计算、随机算法、完全算法、近似算法

### (4) NP-hard类问题

所有的NP问题可以归约到NP-hard问题，但是NP-hard问题不一定是NP问题，公式表达如下：
$$
X\in NP-hard:\forall \ Y\in NP,有Y\le\ _{p}X
$$


[参考资料]()

[计算机算法设计与分析（第五版）王晓东]()

[西安交通大学算法设计课件 田暄]()

([什么是 P = NP 问题？ (qq.com)](https://mp.weixin.qq.com/s?src=11&timestamp=1631710879&ver=3316&signature=gaAfxQk9GadTtIBSVYpq2D6*jSiGgJXUzNVRQULbnWZtNqgHYwkTRgKXLGPDW6hnymziFMLg2qEK4qchuGF-bc53YwX5vz6r3eEwup6vWTp8ILVbnMXImEtKUQ7F9wFa&new=1))

