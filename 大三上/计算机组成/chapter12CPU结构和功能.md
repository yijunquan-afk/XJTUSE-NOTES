[TOC]

# 第十二章 CPU结构和功能

> **1、处理器内部结构，了解就行**
>
> **2、寄存器组织，寄存器分类、用户可见和控制状态寄存器，通用寄存器能存什么,数据和地址寄存器是否区分，长度如何确定，条件代码用来干什么，存在哪里**
>
> **3、控制和状态寄存器了解就行**
>
> **4、指令周期，包括哪几个部分，子周期关系，前后关系，哪些必须，哪些可能**
>
> **5、流水线**
>
> > 为什么要采用流水线，流水策略有哪些，分段，:star: 指令流水操作时序图
>>
> > 哪些因素影响流水线性能、流水线性能衡量标准：加速比与吞吐量要掌握
>
> **5、指令流水线处理条件转移指令的几种方式**

## 12.1 CPU组成

CPU执行指令的步骤：

> 取指令
>
> 解释指令
>
> 取数据
>
> 处理数据
>
> 写数据

为了执行指令，CPU必须包括ALU和CU，同时，CPU需要临时存储一些数据，包括下一条指令的位置。因此，CPU需要一个小的内部内存——寄存器

<img src="https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img2/1695704513.png" alt="image-20211110112906449" style="zoom:50%;" />

## 12.2 寄存器组织

寄存器：CPU中用于暂存的一小块工作空间（I/O中也有）

是CPU设计需要考虑的一个重要因素

> :one: 用户可见寄存器User-visible registers
>
> > 允许机器语言或汇编语言的编程人员通过优化寄存器的使用而减少对主存的访问
>
> :two: 控制和状态寄存器Control and status registers
> 
> > 由控制器来控制CPU的操作，并由拥有特权的操作系统来控制程序的执行

### 用户可见寄存器

**通用目的寄存器general purpose register**

> 也许真的是通用的
>
> 可能是受限制的
>
> 可能有用于浮点和堆栈操作的专用寄存器
>
> 可用于数据或寻址

**数据寄存器**

> 累加器

**地址寄存器**

> 段指针、栈指针

**条件码寄存器**

> 由CPU硬件设置的位，作为最后一次操作的结果
>
> COAPZS
>
> > 正，负，零，溢出，等等，
> >
>
> 在存储最后一个操作的结果之后，还会设置一个条件代码，这个代码可以用于条件分支
>
> 可以被程序隐式地读取、通常不能被程序设置
>
> 对程序员部分可见

**采用更多的通用寄存器/专用寄存器?**

> :one: 采用更多的通用寄存器
>
> > 增加灵活性，给程序员提供了更大的自由，寻址方式也可以更丰富
> >
> > 增加指令的长度和复杂度
>
> :two: 采用更多地专用寄存器
>
> > 更短的指令
> >
> > 灵活性变差

### 控制和状态寄存器

> **程序寄存器PC**：存有待取指令地地址
>
> **指令寄存器IR**：存有最近取来的指令
>
> **存储器地址寄存器MAR**：存有存储器位置的地址
>
> **存储缓冲寄存器MBR**：存有将被写入存储器的数据字或最近被存储器读出的字

很多CPU设计都包括**程序状态字PSW**的一个或一组寄存器，一般含有条件码和其他状态信息。大多对程序员不可见

> 符号sign
>
> 进位carry
>
> 等于equal
>
> 溢出overflow
>
> 中断允许\禁止
>
> 监管supervisor（CPU处在监管模式还是用户模式）

子程序调用，不需要保存现场，就是一段代码的替换

**设计控制寄存器时要考虑两个因素**

:one: 操作系统支持

> CPU设计与操作系统设计是紧密联系在一起的，二者应该相互配合
>

:two: 控制信息分配在内存和寄存器

> 控制信息也可以存储在主存的前几百个字中，设计者必须决定有多少在寄存器中，有多少在内存中

### 微处理器寄存器举例

![image-20211226205539906](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img2/1695704507.png)

## 12.3 指令周期

<img src="https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img2/1695704515.png" alt="image-20211110115010089" style="zoom: 67%;" />

### **间接寻址周期**

可能需要内存访问才能获取操作 

间接处理需要更多的内存访问 

可视为附加指令子周期

<img src="https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img2/1695704516.png" alt="image-20211110115400739" style="zoom:50%;" />

<img src="https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img2/1695704517.png" alt="image-20211110115452013" style="zoom:67%;" />

一旦取来一个指令，它的操作数指定符必须被识别，然后读取存储器中的每个操作数，**这个过程可能要求间接寻址**。寄存器操作数不需要从存储器读取，一旦操作完成，可能需要一个类似的过程将结果存入主存。

### 数据流

假定一个CPU中有一个MAR、一个MBR、一个PC、一个IR

#### 取指周期

> PC存有待取的下一条指令的地址
>
> 地址被送到MAR
>
> 地址放在地址总线中
>
> 控制器发出一个存储器读的请求，存储器根据地址读取到下一条指令的内容
>
> 存储器将结果放在数据总线中，CPU将其复制到MBR，然后传送到IR
>
> 同时，PC+1
>
> <img src="https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img2/1695704519.png" alt="image-20211110115853266" style="zoom:50%;" />

一旦经历过取指周期，控制器会检查IR中的内容

#### 间接周期

> 一旦经历取指周期，检查器检查IR的内容，确定是否有一个使用间接寻址的操作数指定符，若是则进入间接周期
>
> MBR最右边的N位是一个地址引用，被送入MAR
>
> 控制器发一个存储器读，得到操作数地址
>
> 送入MBR
>
> ![image-20211226210853282](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img2/1695704508.png)

#### 执行周期

没有固定地形式，取决于实际执行的指令

#### 中断周期

> PC的当前的内容被保存，以便在中断之后CPU能恢复先前的动作
>
> PC的内容被送到MBR，写入存储器
>
> 一个专门的存储器位置被控制器装入MAR（可能是一个栈指针）
>
> 中断子程序的地址装入PC
>
> 可获取下一个指令（中断处理程序的第一个指令）
>
> <img src="https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img2/1695704520.png" alt="image-20211112102111756" style="zoom:50%;" />

## 12.4 指令流水线（重点）

### 指令预取

可以将指令处理分为两个阶段：取指令和执行指令。在指令执行过程中，主存可能没有存取操作，可以在解码和执行当前指令时获取下一个指令。

![image-20211112102552622](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img2/1695704509.png)

这种方式需要指令缓存，需要更多的寄存器

<img src="https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img2/1695704521.png" alt="image-20211112102941718" style="zoom:80%;" />

预取可以提速，但是速度不会翻一番，若指令之间有关系，会造成无效缓存以及速度降低

### 指令流水线instruction pipelining

处理相关任务时，资源能错开使用，不均等分段会降低流水线的效率

指令流水线可将指令处理分解如下：

> 取指令FI：从cache中读下一条指令
>
> 译码指令DI：decode instruction
>
> 计算操作数CO：计算每个源操作数的有效地址，涉及偏移寻址、寄存器间接寻址等
>
> 取操作数FO：从存储器中取出操作数，寄存器中的数不需要取
>
> 执行指令EI
>
> 写操作数WO

<img src="https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img2/1695704522.png" alt="image-20211112104443134" style="zoom:50%;" />

实际运行中，指令之间肯定会有依赖，条件转移也会降低速度，有条件转移是在**执行阶段**知道转还是不转

> C语言中的goto是无条件转移、for循环是条件转移

<img src="https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img2/1695704524.png" alt="image-20211112105633163" style="zoom:50%;" />

### 流水线性能

指令流水线的周期$\tau$，是在流水线中将一组指令推进一段所需的时间，表示公式如下（<mark>掌握定义</mark>）：
$$
\tau=max_i[\tau_i]+d=\tau_m+d\qquad 1\le i\le k
$$
其中：

> $\tau_i=流水线第i段的电路延迟时间$
>
> $\tau_m=最大段延迟$
>
> $k=指令流水段数$
>
> $d=锁存延时$

通常延时d等于时钟脉冲的宽度而且$\tau_m>>d$

假设现有n条指令在进行，无转移发生，令$T_{k,n}$为k阶段流水线执行所有n条指令所需的总时间，则有:
$$
T_{k,n}=[k+(n-1)]\tau
$$
提速比
$$
s_k=\frac{nk\tau}{[k+(n-1)]\tau}=\frac{nk}{k+(n-1)}
$$
吞吐率$T_p$：**流水线单位时间内产生的指令数**（<mark>掌握定义</mark>）
$$
T_p=\frac{n}{[k+(n-1)]\tau}
$$

$$
T_{pmax}=\frac{1}{\tau}
$$

$n>>k，T_p\thickapprox T_{pmax}$

#### 举例

考虑一个时钟周期为50ns的单流水线处理器有5个流水线阶段:FI、DI、FO、EX和WB。假设每个阶段的持续时间相等，需要2个时钟周期。它需要执行8个连续指令。

绘制流水线各功能阶段时序图，计算提速和吞吐量。假设在执行指令期间没有冲突、依赖或分支。

如果指令4是一个条件转移指令，并且转移的目标是指令7。在此执行中，结果是进行分支。绘制流水线各功能阶段时序图，计算提速和吞吐量。假设在指令8之后，没有其他指令要执行。

![image-20220220180233871](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img2/1695704511.png)

### 流水线相关性pipeline hazard

流水线相关性发生在流水线，因为某些条件不允许流水线亟需运行，而必须停顿，也称为流水线空泡pipeline bubble。有三种类型：

#### 结构相关（资源冲突）resource hazard

发生在两条（或多条）已进入流水线的指令需要使用相同资源的时候

就意味着某些指令的处理过程需要停滞

![image-20211226232412316](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img2/1695704512.png)

#### 数据冲突data hazard

数据冲突发生在对一个操作数位置的访问出现冲突的时候。

> 程序中的两条指令是依次执行，并且都将访问同一个内存或者寄存器操作数。如果这两条指令是严格执行的，那么没问题发生。如果在流水线中运行，可能会使操作数不按次序更新，从而产生不正确的结果

举例：

> <img src="https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img2/1695704525.png" alt="image-20211112115032253" style="zoom:67%;" />
>
> 第一条指令将寄存器EAX和EBX中的内容相加，并将结果保存在EAX寄存器；
>
> 第二条指令从ECX中减去EAX，并将结果存回ECX；
>
> ADD指令

:one: **写后读相关或真实数据相关（RAW）**

> 一条指令改写一个寄存器或内存地址
>
> 而后续的指令从所改写的寄存器或内存地址读取数据
>
> 如果在写操作完成之前，读操作就开始进行，那么就会发生相关

**:two: 读后写相关或反相关（WAR）**

> 一条指令读一个寄存器或内存地址
>
> 而后续的指令又将改写该寄存器或内存地址的内容
>
> 如果在读操作完成之前，写操作就开始执行，那么就会发生相关

:three: **写后写相关或输出相关（WAW）**

> 两条指令要改写同一个寄存器或内存地址
>
> 如果这两条指令的写操作发生次序与期望的次序相反，那么就会发生相关

在按序流动的流水线中，只可能出现**RAW相关**

#### 控制冲突**Control Hazards** 

也称为分支冲突，发生在流水线对分支转移做出了错误的预测，因此读取了后期必须取消的指令的时候。处理办法如下：

:one: **多个指令流multiple streams**

使用两个流水线

每个分支预取到单独的流水线中执行

最终依据条件转移指令结果选择保留其中一条流水线的结果

**问题**

> 导致寄存器和存储器访问的竞争延迟
>
> 多个分支导致需要更多的流水线
>

**应用**

由IBM370,3033使用

:two: **预取分支目标prefetch branch target**

除了取条件分支指令之后的指令外，分支目标处的指令也被预取

预取的结果会放到一个特殊的寄存器

目标被保存直到分支指令被执行

**应用**：IBM 360/91使用

:three: **循环缓冲器loop buffer**

维护一个小的但极高速的存储器，含有n条最近顺序取来的指令

流水线取指阶段维护

若一个转移将要发生，硬件首先检查转移目标是否在此缓冲器中

非常适合小的循环

类似于指令高速缓存，不同在于它只保留顺序的指令，因而容量较小，成本也较低

**应用**：CRAY-1使用

:four: **分支预测**

包括

> 预测绝不发生
>
> 预测总是发生
>
> 依据操作码
>
> > 假定对某些条件转移指令总是预测发生转移，对另外的一些转移总是预测不发生转移
>
> 发送/不发生切换
>
> > Bits (1~2bits)：记录执行转移情况
> >
> > 适合循环和迭代
>
> 转移历史表
>
> > 是一个小容量的Cache --- BTB/BHT

前三种静态，后两种动态：取决于执行的历史

**:five:** 延迟转移

插入NULL操作

> 阻塞流水线
>
> 使用在早期CPU上

重排序指令

> 乱序执行
>
> 目前机器常用
