# 第十一章 指令集：寻址方式和指令格式

## KEY POINTS

> 寻址方式的特点
>
> 为什么那么多寻址方式？
>
> 操作数放在哪
>
> 指令格式，指令长度如何确定
>
> 变长的优势

## 11.1 寻址方式

**寻址方式**：确定当前指令或下一个指令地址中数据地址的方法 

取决于 CPU 硬件并影响指令格式和功能

两种类型：**指令寻址（包括顺序寻址和跳跃寻址）和数据寻址**

寻址技术：

> 立即寻址、直接寻址、间接寻址、寄存器寻址、寄存器间接寻址、偏移寻址、栈寻址
>
> ![](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img2/1695704496.png)

符号说明：

> A: 指令中地址字段的内容
>
> R：指向寄存器的指令地址字段内容
>
> EA：指操作数的真实地址，被访问位置的实际（有效）地址
>
> > 在没有虚拟存储器的系统中，有效地址就是内存的地址或者是寄存器；在虚拟存储器系统中，有效地址就是虚拟地址或者寄存器
>
> X：存储器位置X或寄存器X的内容

### 立即寻址|Immediate Addressing

**操作数是指令的一部分，操作数就是地址**

> 例如：ADD 5
>
> 5就是一个操作数

其加载到数据寄存器中时，标志位将扩展到左侧以实现数据字大小 

最简单的寻址模式，无需访问内存或缓存 

范围有限 

**应用**：

> 定义和使用常数 
>
> 设置可变的初始值

<img src="https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img2/1695704499.png" alt="image-20211110102926350" style="zoom:50%;" />

### 直接寻址|Direct Addressing

**地址字段包含操作的有效地址** 

有效地址 （EA） = 地址字段 （A） 

> 例如。MOV AX， [1070H] 
>
> 将地址 1070H 的内容移动到 AX 
>
> 1070H 是一个内存地址。 

访问数据的单个内存引用 

没有额外的计算来计算有效地址 

地址空间有限

<img src="https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img2/1695704500.png" alt="image-20211110102907461" style="zoom:50%;" />

### 隐含寻址implicit addressing

操作的地址没有明确显示，它隐藏在操作码或**特殊寄存器**，如 AC 

> ADD 5

### 间接寻址indirect addressing

指令中的地址字段（形式地址）不直接给出操作数地址，而是指出有效地址所在的存储单元的地址

操作 EA  =（A） 

查找地址A，找到A中存放的内容(A)，该内容才是真正的操作数有效地址(A)，然后再通过该地址查找到真正的操作数

> 举例：load（A）
>
>  将内存内容地址 A 指向累加寄存器的地址内容加载

![image-20220220165503948](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img2/1695704498.png)

优点

> 更大的地址空间 
>
> 对于一次间接寻址，存储单元为N位字长来说寻址范围可达$2^N$

缺点

> 需要两次（一次间接寻址）或多次 （多次间接寻址） 内存访问来查找操作数
>
> 速度较慢

### 寄存器寻址register addressing

指令中的地址字段（形式地址）直接给出寄存器的编号:EA=R

**优点**

> 指令中仅需要一个较小的地址字段（寄存器的数量有限）
>
> 不需要存储器访问，速度很快

经常使用的变量就定义为寄存器变量

> register int i,j;

<img src="https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img2/1695704501.png" alt="image-20211226193949572" style="zoom:67%;" />

### 寄存器间接地址register indirect addressing

与间接寻址类似，地址字段给出的是寄存器的编号，操作数的有效地址是寄存器里的内容

EA=(R)

<img src="https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img2/1695704502.png" alt="image-20211110104547873" style="zoom:50%;" />

### 偏移寻址displacement addressing

强有力的寻址方式

<mark>EA=A+(R)</mark>

结合了直接寻址和寄存器间接寻址

> 指令要求有两个地址字段
>
> 两者至少有一个是显式的
>
> A = 基址值
>
> R = 偏移地址
>
> 反之亦可

<img src="https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img2/1695704503.png" alt="image-20211110104836847" style="zoom:50%;" />

分为：相对寻址、基址寄存器寻址、变址

#### 相对寻址

R = 程序计数器，PC

 EA = A +（PC） 

A 是位移，视为补充 

有效地址是相对于当前指令地址的位移 

即从 PC 指向的当前位置从 A 单元中获取操作数， 用于跳跃

常用于转移类指令,基于局部性原理，跳转的指令和目前正在执行指令距离不远，那么使用相对寻址可以节省指令中地址码所需的位数

#### 基址寄存器寻址

用于OS的地址转换,常常用于分页或分段后查找真正的物理地址

#### 变址|Indexed Addressing

A=base	R=displacement	EA=A+R

通常适用于数组或循环

<img src="https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img2/1695704504.png" alt="image-20211110105542137" style="zoom:50%;" />

包括后变址和前变址

> 后变址：EA=(A)+(R)
>
> A的内容+R的内容
>
> 前变址：EA=(A+(R))
>
> A+R的内容

### 栈寻址

操作数（隐含的）放在栈顶

SP寄存器指向栈顶

对存储器中栈的访问实际属于寄存器间接寻址

<img src="https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img2/1695704505.png" alt="image-20211226194752996" style="zoom:67%;" />

> 硬栈：寄存器
>
> 软栈：主存

### 总结

> > | 方式                                   | 算法                             | 主要优点                                         | 主要缺点                                   | 操作数位置                               | 应用                 |
> > | -------------------------------------- | -------------------------------- | ------------------------------------------------ | ------------------------------------------ | ---------------------------------------- | -------------------- |
> > | 立即寻址<br />**Immediate Addressing** | 操作数=A                         | 无存储器访问，速度更快                           | 操作数范围有限                             | 操作数在指令中                           | 定义和使用常数       |
> > | 直接寻址<br />direct addressing        | 有效地址 （EA） = 地址字段 （A） | 只要求一次存储器访问无需额外计算就可得出有效地址 | 受限于地址字段长度，只能提供有限的地址空间 | 操作数在地址地段指向的地址中             |                      |
> > | 间接寻址<br />indirect addressing      | EA  =（A）                       | 更大的地址空间                                   | 速度较慢                                   | 操作数在地址地段指向的存储器中           | 中断服务程序入口寻找 |
> > | 寄存器寻址                             | EA=R                             | 无存储器访问                                     | 地址范围有限                               | 操作数在地址地段指向的地址中             | 定义常用变量         |
> > | 偏移寻址displacement addressing        | <mark>EA=A+(R)</mark>            | 灵活                                             | 复杂                                       | 操作数在基地址和偏移间接结合指向的地址中 | 分页或分段           |
> > | 栈寻址stack                            | EA=栈顶                          | 无存储器访问                                     | 应用有限                                   |                                          |                      |
>
> 

## 11.2 指令格式

指令格式通过它的各个构成部分来定义指令的位安排

大多数的指令集使用不止一种指令格式

一个指令格式必须包括一个操作码，以及隐式或显式的、零个或多个操作数

### 指令长度

决定了汇编编程人员所看到的指令的丰富性和灵活度

影响因素

> 内存大小 内存组织 总线结构 CPU 复杂性 CPU 速度

指令长度需在指令的强有力性和存储时节省空间之间进行权衡考虑

指令长度应当等于数据总线宽度或其整数倍数、指令长度应当等于字符长度或定点数长度的整数倍

### 位分配

**对于一个给定的指令长度，显然要在操作码数目和寻址能力之间进行权**衡

> 操作码越多，操作码字段越长，地址码就越少，寻址空间比较有限
>
> 操作码太少，功能就会不全

**使用变长的操作码**

> 指定一个最小操作码长度
>
> 对于某些操作码，可以通过使用指令附加位的方法来指定附加的操作
>
> 只用于要求较少操作数及寻址方式较少的指令的情况

**使用变长指令**

> 提供不同长度的各种指令格式
>
> 操作码长度不同
>
> 寻址方式可更加灵活
>
> 可适用于更复杂的CPU
