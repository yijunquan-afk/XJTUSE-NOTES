[TOC]

# 第十四章 指令级并行性和超标量处理

## :star: key points

> **What is superscalar? Which elements may limit its performance? How to improve the performance?**
>
> **Instruction-issue Policy**
>
> **Register Renaming**
>
> > **1、超标量的概念、特征，与超级流水线的区别**
>>
> > **2、超标量的并行性受到什么因素限制：五大相关；一定要搞清楚什么是乱序发射**
>>
> > **3、超标量中用来提高性能的三种硬件技术：资源复制、无序发射、寄存器重命名，<mark>必须记住</mark>**
>>
> > **4、处理器中要采用超标量方式需要包含哪些硬件功能？5条**
>>
> > **5、了解ROB邮件是什么**

## 14.1 概述

超标量superscalar的方法本质为，**在不同的流水线中并行执行指令的能力，即允许指令能以不同于原来程序顺序的次序来执行**

> 超标量就是对标量指令处理的一种加速

![image-20211119114631200](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img2/1695704532.png)

### 超标量的特征

:one: 多个指令在不同的流水线上并行执行

> 基本特征
>
> 每一个流水线都有若干功能单元，都可以进行指令流水，完全意义上的并行

:two: 允许指令以不同于原程序顺序的次序来执行

### 超标量superscalar与超级流水线super pipelining

多数流水阶段所完成的任务只需要比时钟周期一半还少的时间，于是双倍的内部时钟速率允许**在一个外部时钟周期内完成两个任务。**

**超级流水线**：把流水段划分的更细致些，每个段的执行时间只有半个时钟周期或者更少，它的一个段同步于外部一个的更快的时钟

**区别**

> 超标量是完全意义上的并行，物理上存在多条流水线，多条指令可同步执行
>
> 超级流水线是并发执行，物理上只有一条流水线，只是这条流水线性能更好，各个指令在处理时是部分交叠无法做到真正的同步

<img src="https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img2/1695704536.png" alt="image-20211119115456639" style="zoom:67%;" />

现代处理器往往采用超级流水线超标量技术

### 限制

超标量方法依赖于并行执行多条指令的能力，指令级并行性（instruction level parallelism）指的是程序指令能并行执行的程度。

但并不是超标量中的流水线数目越多性能一定就越好，需要结合编译器优化和硬件技术

**受限因素**如下：

> 真实数据相关性
>
> 过程相关性
>
> 资源冲突
>
> 输出相关性
>
> 反相关性

#### 1、真实数据相关性|True Data Dependency

```C
ADD r1, r2 (r1 := r1+r2;)
MOVE r3,r1 (r3 := r1;)
```

第二条指令能取指并译码，但是在第一条指令执行完成之前不能被执行，因为第二条指令依赖于第一条指令产生的数据。

也成称为写后读相关性和流相关性

#### 2、过程相关性|Procedural Dependency

:one: 多条流水线中出现了转移

> 对普通流水线有影响
>
> 对于超标量来说由转移带来的损失甚至更大

:two: 使用变长指令引起的相关

> 因为任一个指令的具体长度不是事先已知的
>
> 需要部分译码后才能确定需要几次取指
>
> 妨碍了超标量的同时取指
>
> 这里由于RISC的指令格式相对固定，执行时间长短也差不多，**超标量更适合RISC**

#### 3、资源冲突|Resource Conflict

两个或多个指令同时竞争同一资源

> 存储器\总线\功能单元，如：ALU中的加法器\Cache\寄存器

可通过复制资源来克服

#### 4、输出相关性|Output dependency

```c
I1: Add R6, R3 (R6 := R6 + R3;)
......
I4: Mov R6, R7 (R6 := R7;)
```

两条指令可以并行取指和译码

I1完成之前不能执行I4指令

也称为写写相关

#### 5、反相关性|Antidependency

```c
I1: ADD R3, R4 (R3 := R3 + R4;)

I2: MOV R4, R5 (R4 := R5;)
```

两条指令可以并行取指和译码

I1完成之前不能执行I2指令

也成为先读后写相关

## 14.2 设计考虑

### 指令发出策略

**instruction issue指令发出**，是指启动指令去处理器功能单元执行的过程。实际上，指令发出就是处理器试图在当前执行点之前查找能进入流水线并执行的指令。

以下三种类型的排序是重要的：

> 取指令顺序
> 指令执行顺序
> 指令改变寄存器和存储器位置内容的顺序

超标量指令发出策略如下

#### 1、按序发出按序完成

严格的按顺序执行顺序发出指令，并以同样的顺序写结果

举例

> 图14-4a给出这种策略的一个例子。假定超标量流水线一次能取并译码两条指令，有三个分立的功能单元（如整数算术、浮点算术等)，有两个流水写回段的部件。例子是一个6条指令的代码片段，并假定有如下限制:
>
> > I1执行要求两个执行周期。
> > I3和I4为使用同一功能单元而发生冲突。
> > I5依赖于I4产生的值。
> > I5和I6为使用同一功能单元而发生冲突。
> >
> > ![image-20211227102157808](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img2/1695704534.png)

![image-20211124103830314](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img2/1695704535.png)

指令是一次取两条并传送到译码单元。因为指令是成对取，所以下两条指令必须等待，直到译码流水段已完成上次所取指令的译码。为保证按序完成，当有功能单元冲突或功能单元产生结果需要不止一个周期时,指令发射必须停止。
在这个例子中，由译码第一条指令到写回最后结果总共花费的时间是8个时钟周期。

#### 2、按序发出乱序完成

目的是要执行和输出尽可能快，指令发出因资源冲突、数据依赖关系或过程依赖关系而停止，需要更复杂的指令发出逻辑和中断控制

<img src="https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img2/1695704537.png" alt="image-20211124110637411" style="zoom:80%;" />

#### 3、乱序发出乱序完成

对于顺序发出，如果满足依赖关系，流水线将暂停，直到冲突解决。 **为实现乱序发射，将译码流水线与执行流水线解耦**，为此，需要一个缓冲区，称为**指令窗口**。 可以继续获取和解码，直到此窗口已满，即此流水线已满

当执行阶段中的功能单元变成可用时，需要此功能单元的指令就会由指令窗口发射到执行段。只要:one:**指令所需的具体功能单元是可用的,以及:two:没有冲突或相关性阻塞这条指令**,那任何指令都可以被发射。

<img src="https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img2/1695704538.png" alt="image-20211124105246408" style="zoom:80%;" />

指令窗口并不是一个真实的流水段，由寄存器组成

实际上这是一种用一定的时间延迟来换取不相关指令被提前执行的方式

**作用**

> 通过这种方式可以减少流水线停滞的时间，一定程度上解决了真实数据相关、资源冲突以及过程相关带来的问题，减少了流水段停滞发生的概率
>
> 无法解决输出相关性及读后写相关性的问题

### 寄存器重命名

当允许乱序指令发出和/或乱序指令完成时，可能会产生输出相关性（写后写相关性）和反相关性（读后写相关性）。说明了寄存器的值可能不再反映被程序流指定的值顺序。

解决这些相关性的方法是基于传统的资源冲突解决方法：资源复制。现在的技术称为**寄存器重命名**——将不同指令使用的同名寄存器映射到不同的物理寄存器上去

```
R3b:=R3a + R5a    (I1)
R4b:=R3b + 1      (I2)
R3c:=R5a + 1      (I3)
R7b:=R3c + R4b    (I4)
```

**不带下标的寄存器引用指的是指令中找到的逻辑寄存器**。带下标的寄存器引用指向被分配用来保存新值的硬件寄存器。当对一具体逻辑寄存器进行新的分配后，作为源操作数访问那个逻辑寄存器的后续指令要修改成对最近被分配的硬件寄存器的引用(最近是依据程序的指令顺序而定)。

#### 相关性分析举例

**An Example**

> I1: LOAD R1, A
> I2: FADD R2, R1
> I3: FMUL R3, R4
> I4: FADD  R4, R5
> I5: DEC   R6
> I6: FMUL  R6, R7
>
> I1~I2: Write-read dependency
> I3~I4: read-write dependency
> I5~I6: write-read dependency, output dependency
> I2~I4: functional unit dependency
> I3~I6: functional unit dependency
>
> 若无特殊说明，一般认为浮点加乘运算会有资源冲突

### 超标量中提高性能的技术

**三种硬件技术**

> 资源复制、乱序发出、寄存器重命名
>
> 目前的CPU一般是先利用寄存器重命名技术解决反相关、输出相关等问题，再乱序发出，这样可以发出的指令就会更多些

能在超标量处理器中提高性能的三种硬件技术：资源复制、乱序发出和重命名。

<img src="https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/img2/1695704540.png" alt="image-20211124113322684" style="zoom:50%;" />

没有寄存器重命名而添加功能单位可能不会很有价值；若指令窗口太小，数据相关性将妨碍额外功能单位的有效利用

### 超标量实现的硬件条件

:one: 同时取多条指令的取指策略，要有分支预测和超前取指的功能

:two: 确定有关寄存器真相关性的逻辑以及执行期间将这些值和位置联系起来的机制

:three: 并行启动或发射多条指令的机制

:four: 多条指令并行执行所需的资源

:five: 以正确顺序提交处理状态的机制





