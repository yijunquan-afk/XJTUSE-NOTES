

# [XJTUSE DATABASE]——第七章 事务管理技术

![image-20230503183704656](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/image-20230503183704656.png)

## 一、事务的概念

### 事务

事务(Transaction)是用户**定义的一个数据库操作序列， 这些操作要么全做，要么全不做(All or Nothing)，是一个不可分割的工作单位(UOW)。**

事务和程序是两个概念

> 在关系数据库中，一个事务可以是一条SQL语句，一组SQL语句或整个程序。
>
> 一个程序通常包含多个事务。

**事务是恢复和并发控制的基本单位。**

**事务定义**

:one: **COMMIT**

> **事务正常结束。**
>
> 提交事务的**所有操作(读+更新)**。
>
> 事务中所有对数据库的更新写回到磁盘上的物理数据库中。

:two: **ROLLBACK**

> **事务异常终止**
>
> 事务运行的过程中发生了故障，不能继续执行。
>
> **系统将事务中对数据库的所有已完成的操作全部撤销。**
>
> 事务滚回到开始时的状态。

 <img src="https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/imges3/image-20220206212513115.png" alt="image-20220206212513115" style="zoom:67%;" />

### 事务的特性

<mark>**事务的ACID特性：原子性(Atomicity)、一致性(Consistency)、隔离性(Isolation)、持续性(Durability）**</mark>

**保证事务ACID特性是事务处理的任务。**

**破坏事务ACID特性的因素**

> **(1) 多个事务并行运行时，不同事务的操作交叉执行**
>
> 数据库管理系统必须保证多个事务的交叉运行不影响这些事务的隔离性。
>
> **(2)事务在运行过程中被强行停止**
>
> 数据库管理系统必须保证被强行终止的事务对数据库和其他事务没有任何影响。

#### 原子性

事务是数据库的逻辑工作单位

事务中包括的诸操作要么都做，要么都不做

#### 一致性

事务执行的结果必须是使数据库从一个一致性状态变 到另一个一致性状态。

:+1: 一致性状态

> **数据库中只包含成功事务提交的结果**。

:-1: 不一致状态

> 数据库系统运行中发生故障，有些事务尚未完成就被迫中断；这些未完成事务对数据库所做的修改有一部分已写入物理数据库，这时数据库就处于一种不正确的状态

银行转帐：从帐号A中取出一万元，存入帐号B。

定义一个事务，该事务包括两个操作

| **A**     | **B**     |
| --------- | --------- |
| **A=A+1** | **B=B+1** |

这两个操作要么全做，要么全不做

> 全做或者全不做，数据库都处于**一致性状态**。
>
> 如果只做一个操作，用户逻辑上就会发生错误，少了一 万元，数据库就处于**不一致性状态**。

#### 隔离性

**一个事务的执行不能被其他事务干扰**

一个事务内部的操作及使用的数据对其他并发事务是隔离的

并发执行的各个事务之间不能互相干扰

#### 持续性

**持续性也称永久性(Permanence)**

一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。

接下来的其他操作或故障不应该对其执行结果有任何影响。

:label:

**保证事务在故障发生时满足ACID性质的措施称为“恢复”技术。**

**保证多个事务在并行执行时满足ACID性质的措施称为“并发控制”技术。**

**<mark>恢复和并发控制</mark>是保证事务正确运行的两项基本技术，它们被合称为事务管理**

### 事务的操作

基于简化的表达方式，可把事务涉及的基本存取操作分为以下两种：

:one: **Read(X)**：从数据库中将数据对象X读入到执行read操作的事务的一个局部缓冲区中。

:two: **Write(X)**：从执行write的事务的局部缓冲区把数据对象X写入数据库。

Write操作的结果可以暂时存储在内存中，DBMS的恢复子系统和底层操作系统协同控制，以决定写回磁盘的时机。

### 事务的状态

为了在发生故障时方便恢复，系统需要对事务所处的状态进行跟踪记录，包括事务的起始、提交、撤销或终止等信息。

下图所示是事务的状态转移图：

![image-20220206213828952](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/image-20220206213828952.png)

### SQL的事务处理

在SQL中，事务的定义和前面提到的事务的概念类似，即它是一个逻辑工作单元，并且保持原子性。

事务显式的结束语句可以是COMMIT或ROLLBACK，书写形式如下列SQL语句：

```sql
COMMIT [WORK]：提交当前事务，开始执行一个新事务。
ROLLBACK [WORK]：中止当前事务，撤销事务的影响。
```

SQL中每个事务都有属于它的特性，包括存取模式、隔离级别等。

由SET TRANSACTION语句设置，语法格式如下：

```sql
SET TRANSACTION [{READ WRITE |READ ONLY }]……
[ISOLATION LEVEL{READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ| SERIALIZABLE }]……
```

## 二、数据库恢复技术

### 概述

**故障**

> 任何导致运行事务非正常中断，影响数据库中数据的正确性的事件都成为故障。
>
> 故障破坏数据库，造成全部或部分丢失数据。
>
> **故障是不可避免的**：**计算机硬件的失效**、**软件的错误**、**操作员的失误**、**恶意的破坏**



**数据库的恢复**

> 数据库管理系统必须具有把数据库从错误状态恢复到某 一已知的正确状态(亦称为一致状态或完整状态)的功能， 这就是数据库的恢复管理系统对故障的对策。
>
> 恢复子系统是数据库管理系统的一个重要组成部分。
>
> 恢复技术是衡量系统优劣的重要指标

### 故障的种类

各类故障，对数据库的影响有两种可能性

> 一是数据库本身被破坏。
>
> 二是数据库没有被破坏，但数据可能不正确，这是由于事务的运行被非正常终止造成的

#### 事务内部的故障 

有的是可以通过事务程序本身发现的。

有的是非预期的，不能由事务程序处理的。

**事务内部更多的故障是非预期的，是不能由应用程序处理的。**

> 运算溢出
>
> 并发事务发生**死锁**而被选中撤销该事务
>
> 违反了某些完整性限制而被终止等

**以后，事务故障仅指这类非预期的故障**

**事务故障意味着**

> 事务没有达到预期的终点(COMMIT或者显式的ROLLBACK)。
>
> 数据库可能处于不正确状态**。**

**事务故障的恢复：事务撤消(UNDO)**

> 强行回滚(ROLLBACK)该事务。
>
> 撤销该事务已经作出的任何对数据库的修改，使得该事务就象根本没有启动一样。

#### 系统故障

**系统故障称为软故障，是指造成系统停止运转的任何事件，使得系统要重新启动。**

> 整个系统的正常运行突然被破坏。
>
> 所有正在运行的事务都非正常终止。
>
> 不破坏数据库外存。
>
> 内存中数据库缓冲区的信息全部丢失。

**系统故障的常见原因**

> 特定类型的硬件错误(如CPU故障)
>
> 操作系统故障
>
> 数据库管理系统代码错误
>
> 系统断电

**系统故障的恢复**

:one: 发生系统故障时，一些尚未完成的事务的结果可能已送入**物理数据库**，造成数据库可能处于不正确状态。

> 恢复策略：系统重新启动时，恢复程序让所有**非正常终止的事务回滚，<mark>强行撤消(UNDO)</mark>所有未完成事务**

:two: 发生系统故障时，有些已完成的事务可能有一部分甚至全部留在缓冲区，尚未写回到磁盘上的物理数据库中，系统故障使得这些事务对数据库的修改部分或全部丢失。

> 恢复策略：系统重新启动时，恢复程序需要**<mark>重做(REDO)</mark>所有已提交的事务。**

#### 介质故障

**介质故障称为硬故障，指外存故障**

> 磁盘损坏
>
> 磁头碰撞
>
> 瞬时强磁场干扰

**介质故障破坏数据库或部分数据库，并影响正在存取这部分数据的所有事务。**

**介质故障比前两类故障的可能性小得多，但破坏性大得多。**

#### 计算机病毒

计算机病毒已成为计算机系统的主要威胁，自然也是数据 库系统的主要威胁。

数据库一旦被破坏仍要用恢复技术把数据库加以恢复。

### 恢复的实现技术

**恢复操作的基本原理：冗余**

> 利用存储在系统别处的**冗余数据来重建**数据库中已被破坏或不正确的那部分数据。

**恢复的实现技术：复杂**

一个大型数据库产品，恢复子系统的代码要占全部代码的10%以上。

**恢复机制涉及的关键问题**

> **1.** **如何建立冗余数据**
>
> > **数据转储(backup)**
> >
> > **登记日志文件(logging)**
>
> **2.** **如何利用这些冗余数据实施数据库恢复**

#### 数据转储

转储(dump)是指数据库管理员**定期地将整个数据库复制到磁带、磁盘或其他存储介质上保存起来的过程。**

备用的数据文本称为后备副本(backup)或后援副本。

重装后备副本只能将数据库恢复到转储时的状态要想恢复到故障发生时的状态，必须重新运行自 转储以后的所有更新事务

**转储方法**

##### 静态转储与动态转储

**静态转储**

> 在系统中无运行事务时进行的转储操作。
>
> 转储开始时数据库处于一致性状态。
>
> 转储期间不允许对数据库的任何存取、修改活动。
>
> 得到的**一定是一个数据一致性**的副本。
>
> **优点：实现简单。**
>
> **缺点：降低了数据库的可用性。**
>
> 转储必须等待正运行的用户事务结束。
>
> 新的事务必须等转储结束

**动态转储**

> 转储操作与用户事务并发进行。
>
> 转储期间允许对数据库进行存取或修改。
>
> 优点
>
> 不用等待正在运行的用户事务结束。
>
> 不会影响新事务的运行。
>
> **动态转储的缺点**
>
> **不能保证副本中的数据正确有效**。
>
> 例在转储期间的某时刻Tc，系统把数据A=100转储到磁带上，而在下一时刻Td，某一事务将A改为200。后备副本上的A过时了

##### 海量转储与增量转储

**海量转储: 每次转储全部数据库**

**增量转储: 只转储上次转储后更新过的数据**

海量转储与增量转储比较

> 从恢复角度看，使用海量转储得到的后备副本进行恢往往更方便。
>
> 如果数据库很大，事务处理又十分频繁，则增量转储方式更实用更有效

| 转储方式 | 转储状态     |              |
| -------- | ------------ | ------------ |
|          | 动态转储     | 静态转储     |
| 海量转储 | 动态海量转储 | 静态海量转储 |
| 增量转储 | 动态增量转储 | 静态增量转储 |

#### 登记日志文件

##### 日志文件的格式与内容

:one: 什么是日志文件

> **日志文件(log file)是用来记录事务对数据库的更新操作的文件。**

:two: 日志文件的格式

> ① 以记录为单位的日志文件。
>
> 以记录为单位的日志文件，每条日志记录的内容
>
> > 事务标识(标明是哪个事务)
> >
> > 操作类型(插入、删除或修改)
> >
> > 操作对象(记录ID、Block NO)
> >
> > 更新前数据的旧值(对插入操作而言，此项为空值)
> >
> > 更新后数据的新值(对删除操作而言, 此项为空值
>
> ② 以数据块为单位的日志文件。
>
> 以数据块为单位的日志文件，每条日志记录的内容
>
> > 事务标识
> >
> > 被更新的数据块

##### 日志文件的作用

**进行事务故障恢复、进行系统故障恢复、协助后备副本进行介质故障恢复**

##### 登记

为保证数据库是可恢复的，登记日志文件时必须遵循两条原则：

:one: 登记的次序严格按并发事务执行的**时间次序。**

:two: 必须“**先写日志文件，后写数据库**”

> 写日志文件操作：把表示这个修改的日志记录写到日志文件中。
>
> 写数据库操作：把对数据的修改写到数据库中。

### 恢复策略

#### 事务故障的恢复

由恢复子系统**利用日志文件撤消(UNDO)**此事务已对数据库进行的修改

#### 系统故障的恢复

Undo 故障发生时未完成的事务。

Redo 已完成的事务

#### 介质故障的恢复

重装数据库

重做已完成的事务

### 具有检查点的恢复技术

在日志文件中增加检查点记录(checkpoint)。

增加重新开始文件。

恢复子系统在登录日志文件期间动态地维护日志

**检查点记录的内容**

> 建立检查点时刻所有正在执行的事务清单。
>
> 这些事务最近一个日志记录的地址。

**重新开始文件的内容**

> 记录各个检查点记录在日志文件中的地址。

<mark> **使用检查点方法可以改善恢复效率**</mark>

> 当事务T在一个检查点之前提交，T对数据库所做的修改已写入数据库。
>
> 写入时间是在这个检查点建立之前或在这个检查点建立之时。
>
> 在进行恢复处理时，没有必要对事务T执行重做操作

![image-20220206222057955](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/image-20220206222057955.png)

### 数据库镜像

> 数据库管理系统自动把整个数据库或其中的关键数据复制到另一个磁盘上。
>
> 数据库管理系统自动保证镜像数据与主数据的一致性
>
> 每当主数据库更新时，数据库管理系统自动把更新后 的数据复制过去。

**在实际应用中用户往往只选择对关键数据和日志文件镜像。**

**出现介质故障时**

> 可由镜像磁盘继续提供使用。
>
> 同时数据库管理系统自动利用镜像磁盘数据进行数据库的恢复。
>
> 不需要关闭系统和重装数据库副本。

**没有出现故障时**

> 可用于并发操作
>
> 一个用户对数据加排他锁修改数据，其他用户可以读镜像数据库上的数据，而不必等待该用户释放锁

## 三、并发控制技术

### 概述

多事务执行方式

:one: 事务串行执行

> 每个时刻只有一个事务运行，其他事务必须等到这个事务结束以后方能运行
>
> 不能充分利用系统资源，发挥数据库共 享资源的特点

:two: 交叉并发方式(Interleaved Concurrency)

> 在单处理机系统中，事务的并行执行 是这些并行事务的**并行操作轮流交叉运行**。
>
> 单处理机系统中的并行事务并没有真正地并行运行，但能够减少处理机的空闲时间，提高系统的效率

:three: 同时并发方式(simultaneous  concurrency)

> 多处理机系统中，每个处理机可以运行一个事务，多个处理机可以同时运行多个事务，实现多个事务真正 的并行运行。
>
> 最理想的并发方式，但受制于硬件环境。

本文讨论的数据库系统并发控制技术是以**单处理机系统**为基础的。

数据库管理系统必须提供并发控制机制。

并发控制机制是衡量一个数据库管理系统性能的重要标志之一。

### 封锁

#### 定义

封锁就是事务T在对某个数据对象(例如表、记录等)操作之前，先向系统发出请求，对其加锁。

加锁后事务T就对该数据对象有了一定的控制，在事务T 释放它的锁之前，其它的事务不能更新此数据对象。

封锁是实现并发控制的一个非常重要的技术

#### 基本封锁类型

:one: 排它锁(**Exclusive Locks**，简记为**X**锁)

**排它锁又称为写锁**

若事务T对数据对象A加上X锁，则只允许T读取和修改A，其它任何事务都<mark>不能再对A加任何类型的锁</mark>，直到T释放A上的锁。

**保证其他事务在T释放A上的锁之前不能再读取和修改A。**

:two: 共享锁(**Share Locks**，简记为**S**锁)

**共享锁又称为读锁**

若事务**T**对数据对象**A**加上**S**锁，则事务**T**可以读**A** 但不能修改**A**，其它事务<mark>只能再对**A**加**S**锁，而不能加**X**锁</mark>，直到**T**释放**A**上的**S**锁。

保证其他事务可以读**A**，但在**T**释放**A**上的**S**锁之 前不能对**A**做任何修改

#### 锁的相容矩阵

![image-20220207135501580](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/image-20220207135501580.png)

**Y=Yes**，相容的请求 **N=No**，不相容的请求

### 封锁协议

#### 定义

:question: 什么是封锁协议

> 在运用**X**锁和**S**锁对数据对象加锁时，需要约定一些规则，这些规则为封锁协议(**Locking Protocol**)。
>
> > 何时申请**X**锁或**S**锁
> >
> > 持锁时间
> >
> > 何时释放

对封锁方式规定不同的规则，就形成了各种不同的封 锁协议，它们分别在不同的程度上为并发操作的正确调度提供一定的保证。

#### 一级封锁协议

事务**T**在修改数据**R**之前必须先对其加**X**锁，直到事务结束(EOT)才释放。

> 正常结束(**COMMIT**)
>
> 非正常结束(**ROLLBACK**)

一级封锁协议**可防止丢失修改**，并保证事务**T**是可恢复的。

<mark>在一级封锁协议中，如果仅仅是读数据不对其进行修改，是不需要加锁的，所以它不能保证可重复读和不读“脏”数据</mark>

:label: **举例**

![image-20220207141133446](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/imges3/image-20220207141133446.png)

#### 二级封锁协议

一级封锁协议加上事务T在读取数据R之前必须先对其加S锁，读完后即可释放S锁。

二级封锁协议可以防止<mark>**丢失修改和读“脏”数据**。</mark>

在二级封锁协议中，由于读完数据后即可释放S锁，所以它<mark>不能保证可重复读。</mark>

:label: **举例**

![image-20220207142101936](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/image-20220207142101936.png)

#### 三级封锁协议

一级封锁协议加上事务T在读取数据R之前必须先对其加S锁，直到事务结束才释放。

三级封锁协议<mark>可防止丢失修改、读脏数据和不可复读。</mark>

![image-20220207143229509](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/image-20220207143229509.png)

#### 总结

**不同的封锁协议使事务达到的一致性级别不同**

 **封锁协议级别越高，一致性程度越高。**

<img src="https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/imges3/image-20220207143347214.png" alt="image-20220207143347214" style="zoom:67%;" />

### 活锁和死锁

封锁技术可以有效地解决并行操作的一致性问题， 但也带来一些新的问题：

> 死锁
>
> 活锁

#### 活锁

事务T1封锁了数据R。

事务T2又请求封锁R，于是T2等待。

T3也请求封锁R，当T1释放了R上的封锁之后系统首先批准了T3的请求，T2仍然等待。

T4又请求封锁R，当T3释放了R上的封锁之后系统又批准 了T4的请求……

T2有可能永远等待，这就是活锁的情形。

<img src="https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/imges3/image-20220207143853514.png" alt="image-20220207143853514" style="zoom:50%;" />

避免活锁：采用**先来先服务**的策略

> 当多个事务请求封锁同一数据对象时。
>
> 按请求封锁的先后次序对这些事务排队。
>
> 该数据对象上的锁一旦释放，首先批准申请队列中第一个事务获得锁。

#### 死锁

和操作系统一样，基于封锁的并发控制方法可能引起死锁。

一个事务如果申请锁而没有获准，则其必须等待其他事务释放锁，这就形成事务间的“等待”关系。

**当事务中出现“循环”等待时，如果不加干涉，则会一直等待下去，这就是死锁(dead lock)**

事务T1封锁了数据R1，T2封锁了数据R2，T1又请求封锁R2，因T2已封锁了R2，于是T1等待T2释放 R2上的锁，接着T2又申请封锁R1，因T1已封锁了R1，T2也只能等待T1 释放R1上的锁，这样T1在等待T2，而T2又在等待T1，T1和T2两个事务永远 不能结束，形成死锁

<img src="https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/imges3/image-20220207143932442.png" alt="image-20220207143932442" style="zoom:67%;" />

##### 死锁的预防

:one: **一次封锁法**

要求每个事务必须**一次将所有要使用的数据全部加锁**，否则就不能继续执行。

存在的问题: 降低系统并发度。

:two: **顺序封锁法**

顺序封锁法是预先对数据对象**规定一个封锁顺序**，所有事务都按这个顺序实行封锁。

顺序封锁法存在的问题: 维护成本、难以实现

:three: **比较实用的死锁预防方法**

在这种方法中，当事务申请锁而未获准时，不是一律等待，而是让某些事务**卷回重执(retry)**，以避免循环等待。

为区别事务开始执行的先后，每个事务开始时被赋予一个唯一的并随时间递增的整数，称为**时间标记**(time stamp,ts)。

设有2个事务TA和TB，如ts(TA)<ts(TB)，则TA表示早于TB 。也称TA比TB“年老”，或者说TB 比TA“年轻”

**事务重执一般有2种策略**

:one: 等待-死亡(wait-die)策略

在这种策略中，设TB已持有某数据对象R的锁， TA申请同一数据对象的锁而发生冲突时，则按如下规则处理。

```c
 if ts(TA)<ts(TB) then TA waits;
 else{ 
       rollback TA;  /* Die */
       restart TA with the same ts(TA); 
 }
```

**在这种策略中，总是年老的事务等待年轻的事务。**

:two: 击伤-等待(wound-wait)策略

```c
if ts(TA) > ts(TB) then TA waits;
else{
       rollback TB;   /* Die */
       restart TB with the same ts(TB); 
}
```

**在这种策略中，总是年轻的事务等待年老的事务。**

##### 死锁的诊断和解除

:one: 超时法

如果一个事务的等待时间超过了规定的时限，就认为发生了死锁。

优点：实现简单

缺点：

> 有可能误判死锁。
>
> 时限若设置得太长，死锁发生后不能及时发现

:two: 等待图法

<MARK>**图中存在回路，则表示系统中出现了死锁**</mark>

用事务等待图动态反映所有事务的等待情况

事务等待图是一个有向图G=(T，U)。

T为结点的集合，每个结点表示正运行的事务。

U为边的集合，每条边表示事务等待的情况。

**若T1等待T2，则T1，T2之间划一条有向边，从T1指向T2**

​                           ![image-20220207144638051](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/image-20220207144638051.png)    

图(a)中，事务T1等待T2，T2等待T1，产生了死锁

图(b)中，事务T1等待T2，T2等待T3，T3等待T4，T4又等待T1，产生了死锁

图(b)中，事务T3可能还等待T2，在大回路中又有小的回路

**解除死锁**

> 选择一个处理死锁代价最小的事务，将其**撤消。**
>
> 释放此事务持有的所有的锁，使其它事务能继续运行下去。

### 并发调度的可串行性

#### 可串行化调度

可串行化(Serializable)调度

> 多个事务的并发执行是正确的，当且仅当其结果与按某一次序串行地执行这些事务时的结果相同。

可串行性(Serializability)

> 是并发事务正确调度的准则。
>
> <mark>一个给定的并发调度，当且仅当它是可串行化的， 才认为是正确调度</mark>

**现在有两个事务，分别包含下列操作：**

> **事务T1：读B；A=B+1；写回A**
>
> **事务T2：读A；B=A+1；写回B**

**现给出对这两个事务不同的调度策略**

![image-20220207150037296](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/image-20220207150037296.png)

![image-20220207150047652](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/imges3/image-20220207150047652.png)

#### 冲突可串行化调度

冲突可串行化

> 一个比可串行化更严格的条件
>
> 商用系统中的调度器采用

冲突操作：是指不同的事务对同一数据的读写操作和写写操作

```
Ri(x)与Wj(x) /*事务Ti读x，Tj写x，其中i≠j*/
Wi(x)与Wj(x) /*事务Ti写x，Tj写x，其中i≠j*/
```

不能交换(Swap)的动作:

> 同一事务的两个操作
>
> 不同事务的冲突操作

**一个调度Sc在保证冲突操作的次序不变的情况下， 通过交换两个事务不冲突操作的次序得到另一个调度Sc’，如果Sc’是串行的，称调度Sc是<mark>冲突可串行化的调度</mark>。**

若一个调度是冲突可串行化，则一定是可串行化的调度。可用这种方法判断一个调度是否是冲突可串行化的

![image-20220207150418405](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/image-20220207150418405.png)

Sc2等价于一个串行调度T1，T2。所以Sc1是冲突可串行化的调度

**冲突可串行化调度是可串行化调度的充分条件，不是必要条件。还有不满足冲突可串行化条件的可串行化调度**

> 有3个事务 T1=W1(Y)W1(X)，T2=W2(Y)W2(X)，T3=W3(X)
>
> 调度L1=W1(Y)W1(X)W2(Y)W2(X)W3(X)是一个串行调度。
>
> 调度L2=W1(Y)W2(Y)W2(X)W1(X)W3(X)不满足冲突可串行化。但是调度L2是可串行化的，因为L2执行的结果与调度L1相同，Y的值都等于T2的值，X的值都等于T3的值。

### 两段锁协议

#### 定义

两段锁协议:指所有事务必须**分两个阶段对数据项加锁和解锁。**

> 在对任何数据进行读、写操作之前，事务首先要获得对该数据的封锁。
>
> 在释放一个封锁之后，事务不再申请和获得任何其他封锁。

**“**两段”锁的含义

事务的执行分为两个阶段：

> :one: 第一阶段是获得封锁，也称为“扩展”阶段
>
> 事务可以申请获得任何数据项上的任何类型的锁，但是不能释放任何锁
>
> :two: 第二阶段是释放封锁，也称为“收缩”阶段
>
> 事务可以释放任何数据项上的任何类型的锁，但是不能再申请任何锁

#### 辨析

事务遵守两段锁协议是**可串行化调度的充分条件**，而不是必要条件。

若并发事务都遵守两段锁协议，则对这些事务的任何并发调度策略都是可串行化的

若并发事务的一个调度是可串行化的，不一定所有事务都符合两段锁协议

两段锁协议与防止死锁的一次封锁法

> 一次封锁法要求每个事务必须一次将所有要使用的数据全部加锁，否则就不能继续执行，**因此一次封锁法遵守两段锁协议。**
>
> 但是两段锁协议并不要求事务必须一次将所有要使用的数据全部加锁，因此**遵守两段锁协议的事务可能发生死锁**。

**示例**

<img src="https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/imges3/image-20220207151221252.png" alt="image-20220207151221252" style="zoom:67%;" />

### 封锁的粒度

封锁对象的大小称为**封锁粒度**(Granularity)。

封锁的对象:**逻辑单元，物理单元**

例：在关系数据库中，封锁对象：

> 逻辑单元: 属性值、属性值的集合、元组、关系、索引 项、整个索引、整个数据库等。
>
> 物理单元：页(数据页或索引页)、物理记录等。

封锁粒度与系统的并发度和并发控制的开销密切相关。

> 封锁的粒度**越大**，数据库所能够封锁的数据单元就**越少**，并发度就**越小**，系统开销也**越小**；
>
> 封锁的粒度越小，并发度较高，但系统开销也就越大。

选择封锁粒度：需要同时考虑封锁开销和并发度两个因素，适当选择封锁粒度

> 需要处理多个关系的大量元组的用户事务：以数据库为封锁单位。
>
> 需要处理大量元组的用户事务：以关系为封锁单元。
>
> 只处理少量元组的用户事务：以元组为封锁单位。

#### 多粒度封锁

在一个系统中同时支持多种封锁粒度供不同的事务选择。

多粒度树

> 以树形结构来表示多级封锁粒度
>
> 根结点是整个数据库，表示最大的数据粒度
>
> 叶结点表示最小的数据粒度

**举例**

三级粒度树。根结点为数据库，数据库的子结点为关系， 关系的子结点为元组。

<img src="https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/imges3/image-20220207151435266.png" alt="image-20220207151435266" style="zoom:67%;" />

#### 多粒度封锁协议

允许多粒度树中的每个结点被独立地加锁。

对一个结点加锁意味着这个结点的**所有后裔结点** 也被加以同样类型的锁。

在多粒度封锁中一个数据对象可能以两种方式封锁：显式封锁和隐式封锁。

> **显式封锁:** 直接加到数据对象上的封锁。
>
> **隐式封锁:**是该数据对象没有独立加锁，是由于其 上级结点加锁而使该数据对象加上了锁。

显式封锁和隐式封锁的效果是一样的。

系统检查封锁冲突时

> 要检查显式封锁
>
> 还要检查隐式封锁

例如事务**T**要对关系**R1**加**X**锁系统必须搜索其上级结点数据库、关系**R1**还要搜索**R1**的下级结点，即**R1**中的每一个元组。如果其中某一个数据对象已经加了不相容锁，则**T**必须 等待。 

<mark>对某个数据对象加锁，系统要检查</mark>

> **该数据对象**
>
> 有无显式封锁与之冲突。
>
> **所有上级结点**
>
> 检查本事务的显式封锁是否与该数据对象上的隐式封锁 冲突：**(**由上级结点已加的封锁造成的)。
>
> **所有下级结点**
>
> 看上面的显式封锁是否与本事务的隐式封锁(将加到下级结点的封锁)冲突。

#### 意向锁

提高对某个数据对象加锁时系统的检查效率。

如果对一个结点加意向锁，则说明该结点的下层结点正在被加锁。

<mark>对任一结点加基本锁，必须先对它的上层结点加意向锁。</mark>

例如，对任一元组加锁时，必须先对它所在的数据库和关系加意向锁

**常用意向锁**

##### 意向共享锁(Intent Share Lock，简称IS锁)

> 如果对一个数据对象加IS 锁， 表示它的后裔结点拟(意向)加S锁。
>
> 例如：事务T1要对*R*1中某个元组加S锁，则要首先对关 系*R*1和数据库加IS锁

##### 意向排它锁(Intent Exclusive Lock，简称IX锁)

> 如果对一个数据对象加IX锁，表示它的后裔结点拟(意向)加X锁。
>
> 例如：事务T1要对*R*1中某个元组加X锁，则要首先对关系*R*1和数据库加IX锁

##### 共享意向排它锁(Share Intent Exclusive Lock， 简称SIX锁)

> 如果对一个数据对象加SIX锁，表示对它加S锁，再加IX锁，即SIX = S + IX。
>
> 例：对某个表加SIX锁，则表示该事务要读整个表(所以 要对该表加S锁)，同时会更新个别元组(所以要对该表 加IX锁)。

<img src="https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/imges3/image-20220207151807788.png" alt="image-20220207151807788" style="zoom:67%;" />

锁的强度

> 锁的强度是指它对其他 锁的排斥程度。
>
> 一个事务在申请封锁时 以强锁代替弱锁是安全的，反之则不然

<img src="https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/imges3/image-20220207151818951.png" alt="image-20220207151818951" style="zoom:50%;" />                               

具有意向锁的多粒度封锁方法

> 申请封锁时应该按**自上而下**的次序进行。
>
> 释放封锁时则应该按**自下而上**的次序进行

例如：事务T1要对关系R1加S锁。

> 要首先对数据库加IS锁。
>
> 检查数据库和R1是否已加了不相容的锁(X或IX)。
>
> 不再需要搜索和检查R1中的元组是否加了不相容的锁(X锁)。

## 四、习题

![image-20220207152100122](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/imges3/image-20220207152100122.png)

![image-20220207152111148](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/image-20220207152111148.png)

![image-20220207152121042](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/image-20220207152121042.png)

![image-20220207152132454](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/image-20220207152132454.png)

![image-20220207152144102](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/image-20220207152144102.png)

![](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/image-20220207152210187.png)

![image-20220207152222722](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/imges3/image-20220207152222722.png)

![image-20220207152234084](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/image-20220207152234084.png)

![image-20220207152244511](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/image-20220207152244511.png)

![image-20220207152258451](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/image-20220207152258451.png)

![image-20220207152309595](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/imges3/image-20220207152309595.png)

![image-20220207152318914](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/image-20220207152318914.png)

![image-20220207152329398](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/imges3/image-20220207152329398.png)

![image-20220207152339591](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/image-20220207152339591.png)

![image-20220207152351064](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/image-20220207152351064.png)