

# [XJTUSE DATABASE]——第八章 数据库安全性

![image-20230503183831417](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/image-20230503183831417.png)

## 一、概述

### 数据库的不安全因素

**1.非授权用户对数据库的恶意存取和破坏**

> 一些黑客(Hacker)和犯罪分子在用户存取数据库时猎取用户名和用户口令，然后假冒合法用户偷取、修改甚至破坏用户数据。
>
> 数据库管理系统提供的安全措施主要包括用户身份鉴别、存取控制和视图等技术。

**2.数据库中重要或敏感的数据被泄露**

> 黑客和敌对分子千方百计盗窃数据库中的重要数据，一些机密信息被暴露。
>
> 数据库管理系统提供的主要技术有强制存取控制、数据加密存储和加密传输等。
>
> 审计日志分析。

**3.安全环境的脆弱性**

> 数据库的安全性与计算机系统的安全性紧密联系
>
> 计算机硬件、操作系统、网络系统等的安全性
>
> 需要建立一套可信(Trusted)计算机系统的概念和标准

### TCSEC标准

1991年4月美国NCSC(国家计算机安全中心)颁布了《可信计算机系统评估标准关于可信数据库系统的解释》( Trusted Database Interpretation 简称TDI)。

TDI又称**紫皮书**。它将TCSEC扩展到数据库管理系统。

TDI中定义了数据库管理系统的设计与实现中需满足和用以进行安全性级别评估的标准。

TCSEC/TDI，从四个方面来描述安全性级别划分的指标**策略、责任、保证、文档**

#### 等级划分

![image-20220208152630521](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/image-20220208152630521.png)

四组(division)七个等级

>  D
>
>  C(C1，C2)
>
>  B(B1，B2，B3)
>
>  A(A1)

按系统可靠或可信程度逐渐增高。

各安全级别之间具有一种偏序向下兼容的关系，即较高安全性级别提供的安全保护要包含较低级别的所有保护要求，同时提供更多或更完善的保护能力。

D级

> 将一切不符合更高标准的系统均归于D组。
>
> 典型例子：**DOS**是安全标准为D的操作系统。
>
> DOS在安全性方面几乎没有什么专门的机制来保障。

C1级

> 非常初级的自主安全保护。
>
> 能够实现对用户和数据的分离，进行**自主存取控制(DAC)**，保护或限制用户权限的传播。
>
> 现有的商业系统稍作改进即可满足。

C2级

> **安全产品的最低档次**。
>
> 提供受控的存取保护，将C1级的DAC进一步细化，以个人身份注册负责，并实施审计和资源隔离。
>
> 达到C2级的产品在其名称中往往不突出“安全”(Security)这一特色。
>
> 典型例子**Windows 2000， Oracle 7**

**B1级（真正意义上的安全产品）**

> 标记安全保护。“安全”(Security)或“可信的” (Trusted)产品。
>
> 对系统的数据加以标记，对标记的主体和客体实施强制存取控制(MAC)、审计等安全机制
>
> B1级典型例子
>
> 操作系统
>
> 惠普公司的HP-UX BLS release 9.09+ 
>
> 数据库
>
> Oracle公司的Trusted Oracle 7
>
> Sybase公司的Secure SQL Server version 11.0.6

B2级

> 结构化保护。
>
> 建立形式化的安全策略模型并对系统内的所有主体和客体实施DAC和**MAC(强制存取控制)**。

### CC标准（我国的）

提出国际公认的表述信息技术安全性的结构。

把信息产品的安全要求分为：

> 安全功能要求
>
> 安全保证要求

| 评估保证级 | 定　　义                                                     | TCSEC安全级别(近似相当) |
| ---------- | ------------------------------------------------------------ | ----------------------- |
| EAL1       | 功能测试(functionally tested)                                |                         |
| EAL2       | 结构测试(structurally tested)                                | C1                      |
| EAL3       | 系统地测试和检查(methodically tested and checked)            | C2                      |
| EAL4       | 系统地设计、测试和复查(methodically designed， tested， and  reviewed) | B1                      |
| EAL5       | 半形式化设计和测试(semiformally designed and tested)         | B2                      |
| EAL6       | 半形式化验证的设计和测试(semiformally verified design and tested) | B3                      |
| EAL7       | 形式化验证的设计和测试(formally verified design and  tested) | A1                      |

## 二、数据库安全性控制

非法使用数据库的情况

> 编写合法程序绕过数据库管理系统及其授权机制。
>
> 直接或编写应用程序执行非授权操作。
>
> 通过多次合法查询数据库从中推导出一些保密数据。

**数据库安全性控制的常用方法：用户标识和鉴定、存取控制、视图、审计**

### 用户身份鉴别 (Identification & Authentication)

系统提供的最外层安全保护措施

用户标识：由用户名和用户标识号组成(用户标识号在系统整个生命周期内唯一)

用户身份鉴别的方法

> :one: 静态口令鉴别
>
> 静态口令一般由用户自己设定，这些口令是静态不变的。
>
> :two: 动态口令鉴别
>
> 口令是动态变化的，每次鉴别时均需使用动态产生的新口令登录数据库管理系统，即采用一次一密的方法。例如U盾。
>
> :three: 生物特征鉴别
>
> 通过生物特征进行认证的技术，生物特征如指纹、虹膜和掌纹等。
>
> :four: 智能卡鉴别
>
> 智能卡是一种不可复制的硬件，内置集成电路的芯片，具有硬件加密功能。

### 存取控制

**存取控制机制组成**

:one: 定义用户权限，并将用户权限登记到数据字典中。

> 用户对某一数据对象的操作权力称为权限。 
>
> DBMS提供适当的语言来定义用户权限，存放在数据字典中，称做安全规则或授权规则。

:two: 合法权限检查 

> 用户发出存取数据库操作请求。
>
> DBMS查找数据字典，进行合法权限检查。

<mark>**用户权限定义和合法权检查机制**</mark>一起组成了数据库管理系统的存取控制子系统。

**常用存取控制方法**

> :one: **自主存取控制(Discretionary Access Control ，简称DAC)**
>
> >  **C2级**
> >
> >  用户对不同的数据对象有不同的存取权限
> >
> >  不同的用户对同一对象也有不同的权限
> >
> >  用户还可将其拥有的存取权限**转授**给其他用户
>
> :two: **强制存取控制(Mandatory Access Control，简称 MAC)**
>
> > **B1级**
> >
> > 每一个数据对象被标以一定的密级
> >
> > 每一个用户也被授予某一个级别的许可证
> >
> > 对于任意一个对象，只有具有合法许可证的用户才可以存取

#### 自主存取控制方法【SQL考试不考】

通过 SQL 的GRANT 语句和REVOKE 语句实现。

可能存在数据的“无意泄露”。

用户权限组成

> 数据对象
>
> 操作类型

定义用户存取权限：定义用户可以在哪些数据库对象上进行哪些类型的操作。

定义存取权限称为授权

![image-20220208153737440](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/imges3/image-20220208153737440.png)

##### GRANT授权

GRANT语句的一般格式：

```sql
GRANT <权限>[,<权限>]... 
ON <对象类型> <对象名>[,<对象类型> <对象名>]…
TO <用户>[,<用户>]...
[WITH GRANT OPTION];
```

> 语义：将对指定操作对象的指定操作权限授予指定的用户 
>
> 发出GRANT：数据库管理员、数据库对象创建者(即属主Owner)、拥有该权限的用户
>
> 按受权限的用户 ：一个或多个具体用户、PUBLIC(即全体用户) 
>
> **WITH GRANT OPTION子句:**
>
> > 指定：可以再授予
> >
> > 没有指定：不能传播
> >
> > 不允许循环授权

:one: 示例1： 把查询Student表权限授给用户U1

```sql
GRANT SELECT 
ON TABLE Student 
TO U1;
```

:two: 示例2：把对Student表和Course表的全部权限授予用户U2和U3

```sql
GRANT ALL PRIVILIGES 
ON TABLE Student,Course 
TO U2,U3;
```

:three: 示例3：把对表SC的查询权限授予所有用户

```sql
GRANT SELECT 
ON TABLE SC 
TO PUBLIC;
```

:four: 示例4：把查询Student表和修改学生学号的权限授给用户U4

```sql
GRANT UPDATE(Sno), SELECT 
ON TABLE Student 
TO U4;
```

**对属性列的授权时必须明确指出相应属性列名**

:five: 把对表SC的INSERT权限授予U5用户，并允许他再将此权限授予其他用户

```sql
GRANT INSERT 
ON TABLE SC 
TO U5
WITH GRANT OPTION;
```

执行例5后，U5不仅拥有了对表SC的INSERT权限，还可以传播此权限：

```sql
GRANT INSERT 
ON TABLE SC 
TO U6
WITH GRANT OPTION;
```

 同样，U6还可以将此权限授予U7：

```sql
GRANT INSERT 
ON TABLE SC 
TO U7;
```

但U7不能再传播此权限。

##### REVOKE（收回）

授予的权限可以由数据库管理员或其他授权者用REVOKE语句收回

REVOKE语句的一般格式为：

```sql
REVOKE <权限>[,<权限>]... 
ON <对象类型> <对象名>[,<对象类型><对象名>]…
FROM <用户>[,<用户>]...[CASCADE | RESTRICT];
```

##### 创建数据库模式的权限

数据库管理员在创建用户时实现

CREATE USER语句格式

```sql
CREATE  USER  <username> 
[WITH][DBA|RESOURCE|CONNECT];
```

注： CREATE USER不是SQL标准，各个系统的实现相差甚远

只有系统的**超级用户（DBA）才有权**创建一个新的数据库用户

新创建的数据库用户有三种权限：CONNECT、RESOURCE和DBA

如没有指定创建的新用户的权限，默认该用户拥有CONNECT权限。拥有CONNECT权限的用户不能创建新用户，不能创建模式，也不能创建基本表，只能登录数据库

![image-20220208154716503](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/imges3/image-20220208154716503.png)

##### 数据库角色

数据库角色：被命名的一组与数据库操作相关的权限

> 角色是权限的集合 
>
> 可以为一组具有相同权限的用户创建一个角色
>
> 简化授权的过程

:one: 角色的创建

```sql
CREATE ROLE <角色名> 
```

:two: 给角色授权 

```sql
GRANT <权限>[,<权限>]… 
ON <对象类型>对象名 
TO <角色>[,<角色>]…
```

:three: 将一个角色授予其他的角色或用户

```sql
GRANT <角色1>[,<角色2>]…
TO <角色3>[,<用户1>]… 
[WITH ADMIN OPTION]
```

该语句把角色授予某用户，或授予另一个角色。

授予者是角色的创建者或拥有在这个角色上的ADMIN OPTION。

指定了WITH ADMIN OPTION则**获得某种权限的角色或用户还可以把这种权限授予其他角色**。

一个角色的权限：直接授予这个角色的全部权限加上其他角色。授予这个角色的全部权限。

:four: 角色权限的收回 

```sql
REVOKE <权限>[,<权限>]…
ON <对象类型> <对象名>
FROM <角色>[,<角色>]…
```

用户可以回收角色的权限，从而修改角色拥有的权限

**REVOKE执行者是角色的创建**者、拥有在这个(些)角色上的ADMIN OPTION

**示例：通过角色来实现将一组权限授予一个用户。**

步骤如下：

:one: 首先创建一个角色 R1

```sql
CREATE ROLE R1;
```

:two: 然后使用GRANT语句，使角色R1拥有Student表的SELECT、UPDATE、INSERT权限

```sql
GRANT SELECT, UPDATE, INSERT 
ON TABLE Student 
TO R1;
```

:three: 将这个角色授予王平，张明，赵玲。使他们具有角色R1所包含的全部权限

```sql
GRANT R1 
TO 王平,张明,赵玲;
```

:four: 可以一次性通过R1来回收王平的这3个权限

```sql
REVOKE R1 
FROM 王平;
```

示例：角色的权限修改

```sql
GRANT DELETE 
ON TABLE Student
TO R1;
```

 使角色R1在原来的基础上增加了Student表的DELETE 权限

#### 强制存取控制方法

强制存取控制(MAC)

> 保证更高程度的安全性
>
> 对数据本身进行密级标记
>
> 用户不能直接感知或进行控制
>
> 适用于对数据有严格而固定密级分类的部门：军事部门、政府部门

在强制存取控制中，数据库管理系统所管理的全部实体被分为**主体和客体**两大类。

<mark>主体是系统中的活动实体</mark>

> 数据库管理系统所管理的实际用户。
>
> 代表用户的各进程。

<mark>客体是系统中的被动实体，受主体操纵</mark>

> 文件、基本表、索引、视图。

敏感度标记(Label)

> 对于主体和客体，DBMS为它们每个实例(值)指派一个敏感度标记(Label)。
>
> 敏感度标记分成若干级别
>
> > 绝密(Top Secret，TS)
> >
> > 机密(Secret，S)
> >
> > 可信(Confidential，C)
> >
> > 公开(Public，P)
> >
> > TS>=S>=C>=P
>
> 主体的敏感度标记称为**许可证级别**(Clearance Level)。
>
> 客体的敏感度标记称为**密级**(Classification Level)。

强制存取控制规则（大读小写）

> :one: <mark>仅当主体的许可证级别大于或等于客体的密级时，该主体才能读取相应的客体。</mark>
>
> :two: <mark>仅当主体的许可证级别小于或等于客体的密级时，该主体才能写相应的客体。</mark>

> 规则（2），用户可以为写入的数据对象赋予高于自己的许可证级别的密级。
>
> 这样一旦数据被写入，该用户自己也不能再读该数据对象了。
>
> 如果违反了规则（2），就有可能把数据的密级从高流向低，造成数据的泄露。
>
> 例如，某个TS密级的主体把一个密级为TS的数据恶意地降低为P，然后把它写回。这样原来是TS密级的数据大家都可以读到了，造成了TS密级数据的泄露。

#### DAC+MAC检查

先进行自主存取控制（DAC）检查，通过自主存取控制检查的数据对象再由系统进行强制存取控制检查，只有通过强制存取控制检查（MAC）的数据对象可存取。

![image-20220208155627953](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/image-20220208155627953.png)

## 三、视图机制

把要保密的数据对无权存取这些数据的用户隐藏起来，对数据提供一定程度的安全保护。

间接地实现支持存取谓词的用户权限定义。

示例：建立软件学生的视图，把对该视图的SELECT权限授于王平，把该视图上的所有操作权限授于张明。 

先建立软件学生的视图SE_Student

```sql
CREATE VIEW SE_Student
AS 
SELECT *
FROM  Student
WHERE Sdept=‘SE';
```

在视图上进一步定义存取权限

```sql
GRANT SELECT   /*王平只能检索学生的信息 */
ON SE_Student 
TO 王平;
GRANT ALL PRIVILIGES /*张明具有检索、增删改的所有权限 */
ON SE_Student 
TO 张明; 
```

## 四、审计

什么是审计

> 启用一个专用的审计日志(Audit Log)将用户对数据库的所有操作记录在上面。
>
> 审计员利用审计日志。监控数据库中的各种行为，找出非法存取数据的人、时间和内容。
>
> <mark>C2以上安全级别的DBMS必须具有审计功能。</mark>

审计功能的可选性

> 审计很费时间和空间。
>
> DBA可以根据应用对安全性的要求，灵活地打开或关闭审计功能。
>
> 审计功能主要用于安全性要求较高的部门。

审计事件

> 服务器事件
>
> > 审计数据库服务器发生的事件
>
> 系统权限
>
> > 对系统拥有的结构或模式对象进行操作的审计
> >
> > 要求该操作的权限是通过系统权限获得的
>
> 语句事件
>
> > 对SQL语句，如DDL、DML、DQL及DCL语句的审计
>
> 模式对象事件
>
> > 对特定模式对象上进行的SELECT或DML操作的审计  

审计功能

> 基本功能:提供多种审计查阅方式。
>
> 多套审计规则：一般在初始化设定。
>
> 提供审计分析和报表功能。
>
> 审计日志管理功能
>
> > 防止审计员误删审计记录，审计日志必须先转储后删除
> >
> > 对转储的审计记录文件提供完整性和保密性保护
> >
> > 只允许审计员查阅和转储审计记录，不允许任何用户新增和修改审计记录等
>
> 提供查询审计设置及审计记录信息的专门视图

AUDIT语句和NOAUDIT语句

> AUDIT语句：设置审计功能
>
> NOAUDIT语句：取消审计功能

示例：对修改SC表结构或修改SC表数据的操作进行审计

```sql
AUDIT ALTER,UPDATE 
ON SC;
```

示例：取消对SC表的一切审计

```sql
NOAUDIT ALTER,UPDATE 
ON SC;
```

## 五、数据加密

数据加密

> 防止数据库中数据在存储和传输中失密的有效手段

加密的基本思想

> 根据一定的算法将原始数据—明文(Plain text)变换为不可直接识别的格式­—密文(Cipher text)。

加密方法如下：

### 存储加密

#### 透明存储加密

> 内核级加密保护方式，对用户完全透明。
>
> 将数据在写到磁盘时对数据进行加密，授权用户读取数据时再对其进行解密。
>
> 数据库的应用程序不需要做任何修改，只需在创建表语句中说明需加密的字段即可。
>
> **内核级加密方法: 性能较好，安全完备性较高。**

非透明存储加密

> 通过多个加密函数实现

### 传输加密

#### 链路加密

> 在链路层进行加密
>
> 传输信息由**报头和报文**两部分组成
>
> 报文和报头均加密

#### 端到端加密

> 在发送端加密，接收端解密
>
> **只加密报文不加密报头**
>
> 所需密码设备数量相对较少，容易被非法监听者发现并从中获取敏感信息

**基于安全套接层协议**SSL传输方案的实现思路：

> **:one: 确认通信双方端点的可靠性**
>
> 采用基于数字证书的服务器和客户端认证方式。
>
> 通信时均首先向对方提供己方证书，然后使用本地的CA 信任列表和证书撤销列表对接收到的对方证书进行验证。
>
> **:two: 协商加密算法和密钥**
>
> 确认双方端点的可靠性后，通信双方协商本次会话的加密算法与密钥。
>
> **:three: 可信数据传输**
>
> 业务数据在被发送之前将被用某一组特定的密钥进行加密和消息摘要计算，以密文形式在网络上传输
>
> 当业务数据被接收的时候，需用相同一组特定的密钥进行解密和摘要计算

<img src="https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/imges3/image-20220208160336868.png" alt="image-20220208160336868" style="zoom:50%;" />

## 六、其他安全序保护

> :one: **推理控制**
>
> 处理强制存取控制未解决的问题。
>
> 避免用户利用能够访问的数据推知更高密级的数据。
>
> 常用方法
>
> 基于**函数依赖**的推理控制
>
> 基于**敏感关联**的推理控制
>
> :two: **隐蔽信道**
>
> 处理强制存取控制未解决的问题。
>
> :three: **数据隐私保护**
>
> 描述个人控制其不愿他人知道或他人不便知道的个人数据的能力
>
> 范围很广：数据收集、数据存储、数据处理和数据发布等各个阶段 

**数据的完整性和安全性是两个不同概念**

> :one: 数据的完整性
>
> 防止数据库中存在不符合语义的数据，也就是防止数据库中存在不正确的数据。
>
> 防范对象：不合语义的、不正确的数据。
>
> :two: 数据的安全性
>
> 保护数据库防止恶意的破坏和非法的存取。
>
> 防范对象：非法用户和非法操作。

## 七、习题

![image-20220208160552786](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/image-20220208160552786.png)

![image-20220208160603847](https://raw.githubusercontent.com/yijunquan-afk/img-bed-1/main/image-20220208160603847.png)